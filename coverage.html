
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/AntonBezemskiy/go-musthave-metrics/cmd/agent/flags.go (90.6%)</option>
				
				<option value="file1">github.com/AntonBezemskiy/go-musthave-metrics/cmd/agent/info.go (100.0%)</option>
				
				<option value="file2">github.com/AntonBezemskiy/go-musthave-metrics/cmd/agent/main.go (67.9%)</option>
				
				<option value="file3">github.com/AntonBezemskiy/go-musthave-metrics/cmd/server/flags.go (94.2%)</option>
				
				<option value="file4">github.com/AntonBezemskiy/go-musthave-metrics/cmd/server/info.go (100.0%)</option>
				
				<option value="file5">github.com/AntonBezemskiy/go-musthave-metrics/cmd/staticlint/analyzers/mainexit/mainexit.go (90.0%)</option>
				
				<option value="file6">github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/compress/compress.go (83.3%)</option>
				
				<option value="file7">github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/errors/checker/checker.go (100.0%)</option>
				
				<option value="file8">github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/hasher/hasher.go (91.7%)</option>
				
				<option value="file9">github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/logger/logger.go (80.0%)</option>
				
				<option value="file10">github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/builder/buider.go (87.1%)</option>
				
				<option value="file11">github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/checker/checker.go (90.9%)</option>
				
				<option value="file12">github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/collecter/collecter.go (100.0%)</option>
				
				<option value="file13">github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/config/config.go (89.5%)</option>
				
				<option value="file14">github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/pusher/pusher.go (50.0%)</option>
				
				<option value="file15">github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/storage/storage.go (96.8%)</option>
				
				<option value="file16">github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/worker/worker.go (6.7%)</option>
				
				<option value="file17">github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/api/agent/agent.go (82.4%)</option>
				
				<option value="file18">github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/api/agent/impl/impl.go (80.0%)</option>
				
				<option value="file19">github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/api/agent/interceptors/hasher/hasher.go (76.5%)</option>
				
				<option value="file20">github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/api/server/impl/impl.go (85.2%)</option>
				
				<option value="file21">github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/api/server/interceptors/hasher/hasher.go (75.6%)</option>
				
				<option value="file22">github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/api/server/interceptors/ipfilter/ipfilter.go (93.3%)</option>
				
				<option value="file23">github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/api/server/interceptors/logger/logger.go (0.0%)</option>
				
				<option value="file24">github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories/compress.go (86.7%)</option>
				
				<option value="file25">github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories/duration.go (75.0%)</option>
				
				<option value="file26">github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories/hasher.go (89.7%)</option>
				
				<option value="file27">github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories/repositories.go (100.0%)</option>
				
				<option value="file28">github.com/AntonBezemskiy/go-musthave-metrics/internal/server/compress/compress.go (90.5%)</option>
				
				<option value="file29">github.com/AntonBezemskiy/go-musthave-metrics/internal/server/config/config.go (80.0%)</option>
				
				<option value="file30">github.com/AntonBezemskiy/go-musthave-metrics/internal/server/encrypt/encrypt.go (81.2%)</option>
				
				<option value="file31">github.com/AntonBezemskiy/go-musthave-metrics/internal/server/handlers/handlers.go (81.9%)</option>
				
				<option value="file32">github.com/AntonBezemskiy/go-musthave-metrics/internal/server/hasher/hasher.go (100.0%)</option>
				
				<option value="file33">github.com/AntonBezemskiy/go-musthave-metrics/internal/server/ipfilter/ipfilter.go (100.0%)</option>
				
				<option value="file34">github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger/logger.go (92.9%)</option>
				
				<option value="file35">github.com/AntonBezemskiy/go-musthave-metrics/internal/server/pg/store.go (87.9%)</option>
				
				<option value="file36">github.com/AntonBezemskiy/go-musthave-metrics/internal/server/saver/saver.go (79.0%)</option>
				
				<option value="file37">github.com/AntonBezemskiy/go-musthave-metrics/internal/server/storage/storage.go (95.4%)</option>
				
				<option value="file38">github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/encryption/encryption.go (88.6%)</option>
				
				<option value="file39">github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/info/info.go (100.0%)</option>
				
				<option value="file40">github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/ipchecker/ipchecker.go (100.0%)</option>
				
				<option value="file41">github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/ipgetter/ipgetter.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "log"
        "os"
        "strconv"
        "time"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/hasher"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/config"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/encryption"
)

var (
        flagNetAddr    string
        reportInterval *int
        pollInterval   *int
        flagLogLevel   string
        flagKey        string
        rateLimit      *int
        cryptoKey      string
        flagConfigFile string
        flagProtocol   string // HTTP or GRPC
)

func parseFlags() <span class="cov8" title="1">{
        flag.StringVar(&amp;flagNetAddr, "a", "localhost:8080", "address and port to run server")

        reportInterval = flag.Int("r", 10, "report interval")
        pollInterval = flag.Int("p", 2, "poll interval")
        flag.StringVar(&amp;flagLogLevel, "log", "info", "log level")
        flag.StringVar(&amp;flagKey, "k", "", "key for hashing data")
        rateLimit = flag.Int("l", 1, "count of concurrent messages to server")
        flag.StringVar(&amp;cryptoKey, "crypto-key", "", "public key for asymmetric encryption")
        flag.StringVar(&amp;flagConfigFile, "c", "", "name of configuration file")
        flag.StringVar(&amp;flagProtocol, "protocol", "http", "name of using protocol, http or grpc")

        flag.Parse()

        // для случаев, когда в переменной окружения ADDRESS присутствует непустое значение,
        // переопределим адрес агента,
        // даже если он был передан через аргумент командной строки
        parseEnvironment()

        // параметры конфигурации переопределяются параметрами из файла конфигурции, даже если они были переданы через аргументы командной строки
        // или глобальные переменные
        parseConfigFile()

        config.SetReportInterval(time.Duration(*reportInterval))
        config.SetPollInterval(time.Duration(*pollInterval))
        hasher.SetKey(flagKey)
        config.SetCryptoGrapher(encryption.Initialize(cryptoKey, ""))
}</span>

// parseEnvironment - функция для переопределения параметров конфигурации из глобальных переменных.
func parseEnvironment() <span class="cov8" title="1">{
        if envRunAddr := os.Getenv("ADDRESS"); envRunAddr != "" </span><span class="cov8" title="1">{
                flagNetAddr = envRunAddr
        }</span>
        <span class="cov8" title="1">if envReportInterval := os.Getenv("REPORT_INTERVAL"); envReportInterval != "" </span><span class="cov8" title="1">{
                val, err := strconv.Atoi(envReportInterval)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalln("Environment variable \"REPORT_INTERVAL\" must be int")
                }</span>
                <span class="cov8" title="1">*reportInterval = val</span>
        }
        <span class="cov8" title="1">if envPollInterval := os.Getenv("POLL_INTERVAL"); envPollInterval != "" </span><span class="cov8" title="1">{
                val, err := strconv.Atoi(envPollInterval)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalln("Environment variable \"POLL_INTERVAL\" must be int")
                }</span>
                <span class="cov8" title="1">*pollInterval = val</span>
        }
        <span class="cov8" title="1">if envLogLevel := os.Getenv("AGENT_LOG_LEVEL"); envLogLevel != "" </span><span class="cov8" title="1">{
                flagLogLevel = envLogLevel
        }</span>
        <span class="cov8" title="1">if envKey := os.Getenv("KEY"); envKey != "" </span><span class="cov8" title="1">{
                flagKey = envKey
        }</span>

        <span class="cov8" title="1">if envRateLimit := os.Getenv("RATE_LIMIT"); envRateLimit != "" </span><span class="cov8" title="1">{
                val, err := strconv.Atoi(envRateLimit)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalln("Environment variable \"POLL_INTERVAL\" must be int")
                }</span>
                <span class="cov8" title="1">*rateLimit = val</span>
        }
        <span class="cov8" title="1">if envCryptoKey := os.Getenv("CRYPTO_KEY"); envCryptoKey != "" </span><span class="cov8" title="1">{
                cryptoKey = envCryptoKey
        }</span>
        <span class="cov8" title="1">if envConfigFile := os.Getenv("CONFIG"); envConfigFile != "" </span><span class="cov0" title="0">{
                flagConfigFile = envConfigFile
        }</span>
        <span class="cov8" title="1">if envProtocol := os.Getenv("PROTOCOL"); envProtocol != "" </span><span class="cov8" title="1">{
                flagProtocol = envProtocol
        }</span>
}

// parseConfigFile - функция для переопределения параметров конфигурации из файла конфигурации.
func parseConfigFile() <span class="cov8" title="1">{
        // елси на указан файл конфигурации, то оставляю параметры запуска без изменения
        if flagConfigFile == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">configs, err := config.ParseConfigFile(flagConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("parse config file error: %v\n", err)
        }</span>

        // обновляю параметры запуска
        <span class="cov8" title="1">flagNetAddr = configs.Address
        *reportInterval = int(configs.ReportInterval.Duration.Seconds())
        *pollInterval = int(configs.PollInterval.Duration.Seconds())
        cryptoKey = configs.CryptoKey
        flagProtocol = configs.Protocol</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "io"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/info"
)

// buildVersion - версия сборки.
var buildVersion string

// buildDate - дата сборки.
var buildDate string

// buildCommit - сообщение к сборке.
var buildCommit string

// printGlobalInfo - функция для вывода информации о сборке.
func printGlobalInfo(output io.Writer) <span class="cov8" title="1">{
        info.Build(output, buildVersion, buildDate, buildCommit)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/logger"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/collecter"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/config"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/pusher"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/storage"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/worker"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/api/agent"
)

func main() <span class="cov0" title="0">{
        // вывод глобальной информации о сборке
        printGlobalInfo(os.Stdout)

        parseFlags()

        metrics := storage.NewMetricsStats()
        err := run(metrics)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error initialize agent logger: %v\n", err)
        }</span>
        <span class="cov0" title="0">log.Println("Shutdown the agent gracefully")</span>
}

// run - будет полезна при инициализации зависимостей агента перед запуском
func run(metrics *storage.MetricsStats) error <span class="cov8" title="1">{
        // Проверка хранилища на nil
        if metrics == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("storage is nil")
        }</span>

        // инициализация логера
        <span class="cov8" title="1">if err := logger.Initialize(flagLogLevel); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Добавляю многопоточность
        <span class="cov8" title="1">var wg sync.WaitGroup

        // Create a context with cancel function for graceful shutdown
        ctx, cancelCtx := context.WithCancel(context.Background())

        // запуск сбора метрик через определенный промежуток времени
        logger.AgentLog.Info("Running agent", zap.String("address", flagNetAddr), zap.String("rateLimit", fmt.Sprintf("%d", *rateLimit)))
        wg.Add(1)
        go collecter.CollectWithTimer(ctx, metrics, &amp;wg)
        time.Sleep(50 * time.Millisecond)

        // Запуск отправки метрик агентом через http или grpc
        switch flagProtocol </span>{
        case "http":<span class="cov0" title="0">
                startHTTPAgent(ctx, metrics, &amp;wg)</span>
        case "grpc":<span class="cov8" title="1">
                startGRPCAgent(ctx, metrics, "AddMetric", &amp;wg)</span>
        default:<span class="cov0" title="0">
                log.Fatalf("wrong protocol type: %s", flagProtocol)</span>
        }

        // Канал для получения сигнала прерывания
        <span class="cov8" title="1">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)

        // Блокирование до тех пор, пока не поступит сигнал о прерывании
        &lt;-quit
        log.Println("Shutting down agent...")

        // Закрываю контекст, для остановки функции записи данных в канал для отправки на сервер
        cancelCtx()

        wg.Wait()
        return nil</span>
}

// startHTTPAgent - Запуск HTTP агента.
func startHTTPAgent(ctx context.Context, metrics *storage.MetricsStats, wg *sync.WaitGroup) <span class="cov0" title="0">{
        // Размер буферизованного канала равен количеству количеству одновременно исходящих запросов
        var pushTasks = make(chan worker.Task, *rateLimit)
        wg.Add(1)
        go GeneratePushTasks(ctx, pushTasks, "http://"+flagNetAddr, "updates/", metrics, wg)

        // создаю и запускаю воркеры, это и есть пул
        for w := 0; w &lt; *rateLimit; w++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go worker.DoWork(pushTasks, wg)
                logger.AgentLog.Debug("start pushing worker", zap.String("worker", fmt.Sprintf("%d", w)))
        }</span>
}

// GeneratePushTasks - генерирует задачи для их выполнения пулом работников.
func GeneratePushTasks(ctx context.Context, tasks chan&lt;- worker.Task, address, action string, metrics *storage.MetricsStats, wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()
        defer close(tasks)

        sleepInterval := config.GetReportInterval() * time.Second
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case tasks &lt;- *worker.NewTask(address, action, metrics, pusher.PrepareAndPushBatch):<span class="cov8" title="1">
                        time.Sleep(sleepInterval)</span>
                }
        }
}

// startGRPCAgent - Запуск gRPC агента.
func startGRPCAgent(ctx context.Context, metrics *storage.MetricsStats, transmMethod string, wg *sync.WaitGroup) <span class="cov8" title="1">{
        var pushTasks = make(chan struct{}, *rateLimit)

        wg.Add(1)
        go GenerateGRPCPushTasks(ctx, pushTasks, wg)

        // создаю и запускаю воркеры, это и есть пул
        for w := 0; w &lt; *rateLimit; w++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go agent.InitWorkerAndDo(ctx, flagNetAddr, transmMethod, metrics, pushTasks, wg)
                logger.AgentLog.Info("start pushing worker", zap.String("worker", fmt.Sprintf("%d", w)))
        }</span>
}

// GenerateGRPCPushTasks - генерирует задачи для их выполнения пулом работников.
func GenerateGRPCPushTasks(ctx context.Context, tasks chan&lt;- struct{}, wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()
        defer close(tasks)

        sleepInterval := config.GetReportInterval() * time.Second
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case tasks &lt;- struct{}{}:<span class="cov8" title="1">
                        time.Sleep(sleepInterval)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "flag"
        "log"
        "os"
        "strconv"
        "time"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/config"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/encrypt"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/hasher"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/ipfilter"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/saver"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/encryption"
)

var (
        flagNetAddr         string
        flagGRPCNetAddr     string
        flagLogLevel        string
        flagStoreInterval   int
        flagFileStoragePath string
        flagRestore         bool
        flagDatabaseDsn     string
        flagKey             string
        flagCryptoKey       string
        flagConfigFile      string
        flagTrustedSubnet   string
)

// Определяют способ хранения метрик.
const (
        // SAVEINRAM устанавливает созранение метрик в оперативную память
        SAVEINRAM = iota
        // SAVEINRAM устанавливает созранение метрик в файл
        SAVEINFILE
        // SAVEINRAM устанавливает созранение метрик в базу данных
        SAVEINDATABASE
)

func parseFlags() int <span class="cov8" title="1">{
        flag.StringVar(&amp;flagNetAddr, "a", ":8080", "address and port to run server")
        flag.StringVar(&amp;flagGRPCNetAddr, "grpc-address", ":8082", "address and port to run grpc server")
        flag.StringVar(&amp;flagLogLevel, "l", "info", "log level")
        // настройка флагов для хранения метрик в файле
        flagStoreIntervalTemp := flag.Int("i", 300, "interval of saving metrics to the file")
        flag.StringVar(&amp;flagFileStoragePath, "f", "", "path address to saving metrics file") // Путь к файлу по умолчанию: ./metrics.json
        flagRestoreTemp := flag.Bool("r", true, "for define needed of loading metrics from file while server starting")
        // настройка флагов для хранения метрик в базе данных
        flag.StringVar(&amp;flagDatabaseDsn, "d", "", "database connection address") // host=localhost user=metrics password=metrics dbname=metricsdb  sslmode=disable
        flag.StringVar(&amp;flagKey, "k", "", "key for hashing data")
        flag.StringVar(&amp;flagCryptoKey, "crypto-key", "", "private key for asymmetric encryption")
        flag.StringVar(&amp;flagConfigFile, "c", "", "name of configuration file")
        flag.StringVar(&amp;flagTrustedSubnet, "t", "", "Classless Distributed Ranging (CIDR) string representation")

        flag.Parse()
        flagStoreInterval = *flagStoreIntervalTemp
        flagRestore = *flagRestoreTemp

        // параметры конфигурации переопределяются глобальными переменными, даже если они были переданы через аргументы командной строки
        parseEnvironment()

        // параметры конфигурации переопределяются параметрами из файла конфигурции, даже если они были переданы через аргументы командной строки
        // или глобальные переменные
        parseConfigFile()

        saver.SetStoreInterval(time.Duration(flagStoreInterval))
        saver.SetFilestoragePath(flagFileStoragePath)
        saver.SetRestore(flagRestore)
        hasher.SetKey(flagKey)
        encrypt.SetCryptoGrapher(encryption.Initialize("", flagCryptoKey))
        ipfilter.SetTrustedSubnet(flagTrustedSubnet)

        if flagDatabaseDsn != "" </span><span class="cov8" title="1">{
                return SAVEINDATABASE
        }</span> else<span class="cov8" title="1"> if flagFileStoragePath != "" </span><span class="cov0" title="0">{
                return SAVEINFILE
        }</span>
        <span class="cov8" title="1">return SAVEINRAM</span>
}

// parseEnvironment - функция для переопределения параметров конфигурации из глобальных переменных.
func parseEnvironment() <span class="cov8" title="1">{
        if envRunAddr := os.Getenv("ADDRESS"); envRunAddr != "" </span><span class="cov8" title="1">{
                flagNetAddr = envRunAddr
        }</span>
        <span class="cov8" title="1">if envRunGRPCAddr := os.Getenv("GRPC_ADDRESS"); envRunGRPCAddr != "" </span><span class="cov8" title="1">{
                flagGRPCNetAddr = envRunGRPCAddr
        }</span>
        <span class="cov8" title="1">if envLogLevel := os.Getenv("SERVER_LOG_LEVEL"); envLogLevel != "" </span><span class="cov8" title="1">{
                flagLogLevel = envLogLevel
        }</span>
        <span class="cov8" title="1">if envStoreInterval := os.Getenv("STORE_INTERVAL"); envStoreInterval != "" </span><span class="cov8" title="1">{
                interval, err := strconv.Atoi(envStoreInterval)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Parse STORE_INTERVAL global variable error: %v\n", err)
                }</span>
                <span class="cov8" title="1">flagStoreInterval = interval</span>
        }
        <span class="cov8" title="1">if envFileStoragePath := os.Getenv("FILE_STORAGE_PATH"); envFileStoragePath != "" </span><span class="cov8" title="1">{
                flagFileStoragePath = envFileStoragePath
        }</span>
        <span class="cov8" title="1">if envRestore := os.Getenv("RESTORE"); envRestore != "" </span><span class="cov8" title="1">{
                r, err := strconv.ParseBool(envRestore)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Parse RESTORE global variable error: %v\n", err)
                }</span>
                <span class="cov8" title="1">flagRestore = r</span>
        }
        <span class="cov8" title="1">if envDatabaseDsn := os.Getenv("DATABASE_DSN"); envDatabaseDsn != "" </span><span class="cov8" title="1">{
                flagDatabaseDsn = envDatabaseDsn
        }</span>
        <span class="cov8" title="1">if envKey := os.Getenv("KEY"); envKey != "" </span><span class="cov8" title="1">{
                flagKey = envKey
        }</span>
        <span class="cov8" title="1">if envCryptoKey := os.Getenv("CRYPTO_KEY"); envCryptoKey != "" </span><span class="cov8" title="1">{
                flagCryptoKey = envCryptoKey
        }</span>
        <span class="cov8" title="1">if envConfigFile := os.Getenv("CONFIG"); envConfigFile != "" </span><span class="cov8" title="1">{
                flagConfigFile = envConfigFile
        }</span>
        <span class="cov8" title="1">if envTrustedSubnet := os.Getenv("TRUSTED_SUBNET"); envTrustedSubnet != "" </span><span class="cov8" title="1">{
                flagTrustedSubnet = envTrustedSubnet
        }</span>
}

// parseConfigFile - функция для переопределения параметров конфигурации из файла конфигурации.
func parseConfigFile() <span class="cov8" title="1">{
        // если не указан файл конфигурации, то оставляю параметры запуска без изменения
        if flagConfigFile == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">configs, err := config.ParseConfigFile(flagConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("parse config file error: %v\n", err)
        }</span>

        // обновляю параметры запуска
        <span class="cov8" title="1">flagNetAddr = configs.Address
        flagGRPCNetAddr = configs.GRPCAddress
        flagLogLevel = configs.LogLevel
        flagRestore = configs.Restore
        flagStoreInterval = int(configs.StoreInterval.Duration.Seconds())
        flagFileStoragePath = configs.StoreFile
        flagDatabaseDsn = configs.DatabaseDSN
        flagCryptoKey = configs.CryptoKey
        flagTrustedSubnet = configs.TrustedSubnet</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "io"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/info"
)

// buildVersion - версия сборки.
var buildVersion string

// buildDate - дата сборки.
var buildDate string

// buildCommit - сообщение к сборке.
var buildCommit string

func printGlobalInfo(output io.Writer) <span class="cov8" title="1">{
        info.Build(output, buildVersion, buildDate, buildCommit)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// пакет analyzer представляет собой статический анализатор, который
// выявляет использование os.Exit в функции main.
package mainexit

import (
        "go/ast"
        "strings"

        "golang.org/x/tools/go/analysis"
)

// Analyzer - экспортируемая переменная для использования анализатора.
var Analyzer = &amp;analysis.Analyzer{
        Name: "mainexitcheck",
        Doc:  "check for using os.Exit in main function",
        Run:  run,
}

// isOsExitCalling - проверяет, является ли вызов функцией os.Exit.
func isOsExitCalling(pass *analysis.Pass, call *ast.CallExpr) bool <span class="cov8" title="1">{
        // Проверка, что вызов функции состоит из двух частей: os и Exit
        if sel, ok := call.Fun.(*ast.SelectorExpr); ok </span><span class="cov8" title="1">{
                // Проверяем, что имя метода — "Exit"
                if sel.Sel.Name == "Exit" </span><span class="cov8" title="1">{
                        // Проверяем, что идентификатор — "os"
                        if ident, ok := sel.X.(*ast.Ident); ok &amp;&amp; ident.Name == "os" </span><span class="cov8" title="1">{
                                // Проверяем, что пакет "os" импортирован
                                for _, imp := range pass.Pkg.Imports() </span><span class="cov8" title="1">{
                                        if imp.Path() == "os" </span><span class="cov8" title="1">{
                                                return true
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}

// run - основная функция анализа, которая запускается анализатором.
func run(pass *analysis.Pass) (interface{}, error) <span class="cov8" title="1">{
        for _, file := range pass.Files </span><span class="cov8" title="1">{
                // пропускаю файлы кэша, чтобы анализировать только исходные файлы
                filename := pass.Fset.Position(file.Pos()).Filename
                if strings.Contains(filename, "/.cache/go-build") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Проходим по каждому узлу AST файла
                <span class="cov8" title="1">ast.Inspect(file, func(node ast.Node) bool </span><span class="cov8" title="1">{
                        // Проверяем, что текущий узел — это определение функции
                        if fn, ok := node.(*ast.FuncDecl); ok </span><span class="cov8" title="1">{
                                // Проверяем, что это функция main
                                if fn.Name.Name == "main" </span><span class="cov8" title="1">{
                                        // Проходим по выражениям в теле функции
                                        for _, stmt := range fn.Body.List </span><span class="cov8" title="1">{
                                                // Проверяем, является ли выражение вызовом функции os.Exit
                                                if exprStmt, ok := stmt.(*ast.ExprStmt); ok </span><span class="cov8" title="1">{
                                                        if call, ok := exprStmt.X.(*ast.CallExpr); ok &amp;&amp; isOsExitCalling(pass, call) </span><span class="cov8" title="1">{
                                                                pass.Reportf(call.Pos(), "using os.Exit in main function is prohibited")
                                                        }</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov8" title="1">return true</span>
                })
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package compress

import (
        "bytes"
        "compress/gzip"
        "fmt"
)

// Compress сжимает слайс байт.
func Compress(data []byte) ([]byte, error) <span class="cov8" title="1">{
        var b bytes.Buffer
        // создаём переменную w — в неё будут записываться входящие данные,
        // которые будут сжиматься и сохраняться в bytes.Buffer
        w := gzip.NewWriter(&amp;b)

        // запись данных
        _, err := w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed write data to compress temporary buffer: %v", err)
        }</span>
        // обязательно нужно вызвать метод Close() — в противном случае часть данных
        // может не записаться в буфер b; если нужно выгрузить все упакованные данные
        // в какой-то момент сжатия, используйте метод Flush()
        <span class="cov8" title="1">err = w.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed compress data: %v", err)
        }</span>
        // переменная b содержит сжатые данные
        <span class="cov8" title="1">return b.Bytes(), nil</span>
}

// Decompress распаковывает слайс байт.
func Decompress(data []byte) ([]byte, error) <span class="cov8" title="1">{
        // переменная r будет читать входящие данные и распаковывать их
        r, err := gzip.NewReader(bytes.NewReader(data))
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed decompress data: %v", err)
        }</span>
        <span class="cov8" title="1">defer r.Close()

        var b bytes.Buffer
        // в переменную b записываются распакованные данные
        _, er := b.ReadFrom(r)
        if er != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed decompress data: %v", err)
        }</span>

        <span class="cov8" title="1">return b.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package checker

import (
        "errors"
        "os"
        "strings"
        "syscall"

        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5/pgconn"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/logger"
)

// IsConnectionRefused - проверка того, что ошибка это "connect: connection refused"
func IsConnectionRefused(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">res := errors.Is(err, syscall.ECONNREFUSED) || strings.Contains(err.Error(), "dial tcp: connect: connection refused")
        if res </span><span class="cov8" title="1">{
                logger.AgentLog.Debug("error isConnectionRefused")
        }</span>
        <span class="cov8" title="1">return res</span>
}

// IsDBTransportError - проверяет, что ошибка относится к DBTransportError
func IsDBTransportError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">asPgError := false
        var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                asPgError = (pgerrcode.IsConnectionException(pgErr.Code) ||
                        pgErr.Code == pgerrcode.ConnectionDoesNotExist ||
                        pgErr.Code == pgerrcode.ConnectionFailure ||
                        pgErr.Code == pgerrcode.SQLClientUnableToEstablishSQLConnection)
        }</span>
        <span class="cov8" title="1">asString := false
        asString = strings.Contains(err.Error(), "connection exception") ||
                strings.Contains(err.Error(), "connection does not exist") ||
                strings.Contains(err.Error(), "connection failure") ||
                strings.Contains(err.Error(), "SQL client unable to establish SQL connection")
        res := asPgError || asString
        if res </span><span class="cov8" title="1">{
                logger.AgentLog.Debug("error isDBTransportError")
        }</span>
        <span class="cov8" title="1">return res</span>
}

// IsFileLockedError - проверяет, что ошибка относится к FileLockedError
func IsFileLockedError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">asError := false
        asError = errors.Is(err, syscall.EACCES) ||
                errors.Is(err, syscall.EROFS) ||
                errors.Is(err, os.ErrPermission)

        asString := false
        asString = strings.Contains(err.Error(), "permission denied") ||
                strings.Contains(err.Error(), "read-only file system")
        res := asError || asString
        if res </span><span class="cov8" title="1">{
                logger.AgentLog.Debug("error isFileLockedError")
        }</span>
        <span class="cov8" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package hasher

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "fmt"
        "net/http"

        "github.com/go-resty/resty/v2"
        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/logger"
)

var key string

// SetKey - устанавливает секретный ключ для подписи и расшифровки данных.
func SetKey(k string) <span class="cov8" title="1">{
        key = k
}</span>

// GetKey - получает установленный секретный ключ.
func GetKey() string <span class="cov8" title="1">{
        return key
}</span>

// VerifyHashMiddleware - проверяет хэш тела ответа
func VerifyHashMiddleware(c *resty.Client, resp *resty.Response) error <span class="cov8" title="1">{
        // Если ключ не задан, то проверять подпись данных не нужно
        if k := GetKey(); k == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Если ответ сервера
        <span class="cov8" title="1">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Получаем тело ответа в виде байтов
        <span class="cov8" title="1">bodyBytes := resp.Body()

        // Извлекаем хэш из заголовка ответа
        serverHash := resp.Header().Get("HashSHA256")
        if serverHash == "" </span><span class="cov8" title="1">{
                return errors.New("missing HashSHA256 header in the response")
        }</span>
        // Логирование заголовка
        <span class="cov8" title="1">logger.AgentLog.Debug("Received HashSHA256 header and body", zap.String("header", serverHash), zap.String("body", fmt.Sprintf("%x", bodyBytes)))

        serverHashBytes, err := hex.DecodeString(serverHash)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // подписываем алгоритмом HMAC, используя SHA-256
        <span class="cov8" title="1">h := hmac.New(sha256.New, []byte(GetKey()))
        _, err = h.Write(bodyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">hash := h.Sum(nil)

        // проверяю хэши
        if !hmac.Equal(hash, serverHashBytes) </span><span class="cov8" title="1">{
                err := fmt.Errorf("want %x, get %x", hash, serverHashBytes)
                logger.AgentLog.Error("hashs is not equal ", zap.String("error: ", error.Error(err)))
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package logger

import "go.uber.org/zap"

// Log будет доступен всему коду как синглтон.
// Никакой код, кроме функции InitLogger, не должен модифицировать эту переменную.
// По умолчанию установлен no-op-логер, который не выводит никаких сообщений.
var AgentLog *zap.Logger = zap.NewNop()

// Initialize - инициализирует синглтон логера с необходимым уровнем логирования.
func Initialize(level string) error <span class="cov8" title="1">{
        // преобразуем текстовый уровень логирования в zap.AtomicLevel
        lvl, err := zap.ParseAtomicLevel(level)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // создаём новую конфигурацию логера
        <span class="cov8" title="1">cfg := zap.NewProductionConfig()
        // устанавливаем уровень
        cfg.Level = lvl
        // создаём логер на основе конфигурации
        zl, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // устанавливаем синглтон
        <span class="cov8" title="1">AgentLog = zl.With(zap.String("role", "agent"))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package builder

import (
        "fmt"
        "strconv"

        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/logger"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/storage"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
)

// BuildSlice - функция для создания слайса метрик.
func BuildSlice(metrics *storage.MetricsStats) []repositories.Metric <span class="cov8" title="1">{
        metricsSlice := make([]repositories.Metric, 0)
        if metrics == nil </span><span class="cov8" title="1">{
                return metricsSlice
        }</span>

        // создаю слайс с метриками для отправки батчем
        <span class="cov8" title="1">for _, metricName := range storage.AllMetrics </span><span class="cov8" title="1">{
                typeMetric, value, err := metrics.GetMetricString(metricName)
                if err != nil </span><span class="cov0" title="0">{
                        logger.AgentLog.Error(fmt.Sprintf("Failed to get metric %s: %v\n", typeMetric, err), zap.String("action", "push metrics"))
                        continue</span>
                }
                <span class="cov8" title="1">metric, err := Build(typeMetric, metricName, value)
                if err != nil </span><span class="cov0" title="0">{
                        logger.AgentLog.Error(fmt.Sprintf("Failed to build metric structer %s: %v\n", typeMetric, err), zap.String("action", "push metrics"))
                        continue</span>
                }
                <span class="cov8" title="1">metricsSlice = append(metricsSlice, metric)</span>
        }
        <span class="cov8" title="1">return metricsSlice</span>
}

// Build - строит структуру метрики из принятых параметров типа string.
func Build(typeMetric, nameMetric, valueMetric string) (metric repositories.Metric, err error) <span class="cov8" title="1">{
        metric.ID = nameMetric
        metric.MType = typeMetric

        switch typeMetric </span>{
        case "counter":<span class="cov8" title="1">
                val, errParse := strconv.ParseInt(valueMetric, 10, 64)
                if errParse != nil </span><span class="cov8" title="1">{
                        err = errParse
                        return
                }</span>
                <span class="cov8" title="1">metric.Delta = &amp;val</span>
        case "gauge":<span class="cov8" title="1">
                val, errParse := strconv.ParseFloat(valueMetric, 64)
                if errParse != nil </span><span class="cov8" title="1">{
                        err = errParse
                        return
                }</span>
                <span class="cov8" title="1">metric.Value = &amp;val</span>
        default:<span class="cov8" title="1">
                err = fmt.Errorf("get invalid type of metric: %s", typeMetric)
                return</span>
        }
        <span class="cov8" title="1">logger.AgentLog.Debug(fmt.Sprintf("Success build metric structure for JSON: name: %s, type: %s, delta: %d, value: %d", metric.ID, metric.MType, metric.Delta, metric.Value))
        return</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package checker

import (
        "math"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
)

// equalFloat - функция для проверки на равенство двух чисел типа float64.
func EqualFloat(n1 float64, n2 float64) bool <span class="cov8" title="1">{
        return (math.Abs(n1 - n2)) &lt; 0.0001
}</span>

// Equal - функция для проверки, что две метрики одинаковые.
func Equal(m1 repositories.Metric, m2 repositories.Metric) bool <span class="cov8" title="1">{
        if m1.ID != m2.ID </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if m1.MType != m2.MType </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">switch m1.MType </span>{
        case "gauge":<span class="cov8" title="1">
                if !EqualFloat(*m1.Value, *m2.Value) </span><span class="cov0" title="0">{
                        return false
                }</span>
        case "counter":<span class="cov8" title="1">
                if *m1.Delta != *m2.Delta </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package collecter

import (
        "context"
        "sync"
        "time"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/config"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/storage"
)

// CollectWithTimer запускает сбор метрик через заданный интервал времени.
func CollectWithTimer(ctx context.Context, metrics *storage.MetricsStats, wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()

        sleepInterval := config.GetPollInterval() * time.Second
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                default:<span class="cov8" title="1">
                        config.SyncCollectMetrics(metrics)
                        time.Sleep(sleepInterval)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "time"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/storage"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/encryption"
)

var (
        pollInterval   time.Duration            = 2
        reportInterval time.Duration            = 10
        contextTimeout                          = 500 * time.Millisecond
        cryptoGrapher  encryption.Cryptographer // переменная, которая хранит структуру шифрования и расшифровки.
)

// Configs представляет структуру конфигурации
type Configs struct {
        Address        string                `json:"address"`         // аналог переменной окружения ADDRESS или флага -a
        ReportInterval repositories.Duration `json:"report_interval"` // аналог переменной окружения REPORT_INTERVAL или флага -r
        PollInterval   repositories.Duration `json:"poll_interval"`   // аналог переменной окружения POLL_INTERVAL или флага -p
        CryptoKey      string                `json:"crypto_key"`      // аналог переменной окружения CRYPTO_KEY или флага -crypto-key
        Protocol       string                `json:"protocol"`        // аналог переменной окружения PROTOCOL или флага -protocol
}

// SetPollInterval устанавливает интервал между сбором.
func SetPollInterval(interval time.Duration) <span class="cov8" title="1">{
        pollInterval = interval
}</span>

// GetPollInterval - функция для получения интервала сбора метрик.
func GetPollInterval() time.Duration <span class="cov8" title="1">{
        return pollInterval
}</span>

// SetReportInterval устанавливает интервал между отправками метрик на сервер.
func SetReportInterval(interval time.Duration) <span class="cov8" title="1">{
        reportInterval = interval
}</span>

// GetReportInterval - функция для получения интервала отправки метрик на сервер.
func GetReportInterval() time.Duration <span class="cov8" title="1">{
        return reportInterval
}</span>

// SetContextTimeout - установка таймаута.
func SetContextTimeout(timeout time.Duration) <span class="cov8" title="1">{
        contextTimeout = timeout
}</span>

// GetContextTimeout - получение таймаута.
func GetContextTimeout() time.Duration <span class="cov8" title="1">{
        return contextTimeout
}</span>

// SyncCollectMetrics - собирает метрики.
func SyncCollectMetrics(metrics *storage.MetricsStats) <span class="cov8" title="1">{
        metrics.CollectMetrics()
}</span>

// SetCryptoGrapher - функция для установки структуры шифрования и расшифровки.
func SetCryptoGrapher(c *encryption.Cryptographer) <span class="cov8" title="1">{
        cryptoGrapher = *c
}</span>

// GetCryptoGrapher - функция для получения структуры шифрования и расшифровки.
func GetCryptoGrapher() encryption.Cryptographer <span class="cov8" title="1">{
        return cryptoGrapher
}</span>

// ParseConfigFile - функция для переопределения параметров конфигурации из файла конфигурации.
func ParseConfigFile(configFileName string) (Configs, error) <span class="cov8" title="1">{
        var configs Configs
        f, err := os.Open(configFileName)
        if err != nil </span><span class="cov0" title="0">{
                return Configs{}, fmt.Errorf("open cofiguration file error: %w", err)
        }</span>
        <span class="cov8" title="1">reader := bufio.NewReader(f)
        dec := json.NewDecoder(reader)
        err = dec.Decode(&amp;configs)
        if err != nil </span><span class="cov0" title="0">{
                return Configs{}, fmt.Errorf("parse cofiguration file error: %w", err)
        }</span>

        <span class="cov8" title="1">return configs, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package pusher

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/go-resty/resty/v2"
        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/compress"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/hasher"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/logger"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/builder"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/config"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/storage"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/ipgetter"
)

// Push - отправляет метрику на сервер в JSON формате и возвращает ошибку при неудаче.
func PushJSON(address, action, typeMetric, nameMetric, valueMetric string, client *resty.Client) error <span class="cov8" title="1">{
        metric, err := builder.Build(typeMetric, nameMetric, valueMetric)
        if err != nil </span><span class="cov8" title="1">{
                logger.AgentLog.Error("Build metric error", zap.String("error", error.Error(err)))
                return err
        }</span>

        // сериализую полученную струтктуру с метриками в json-представление  в виде слайса байт
        <span class="cov8" title="1">var bufEncode bytes.Buffer
        enc := json.NewEncoder(&amp;bufEncode)
        if err := enc.Encode(metric); err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Encode message error", zap.String("error", error.Error(err)))
                return err
        }</span>

        // Сжатие данных для передачи
        <span class="cov8" title="1">compressBody, err := compress.Compress(bufEncode.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Fail to comperess push data ", zap.String("error", error.Error(err)))
                return err
        }</span>

        // Шифрование сжатых данных если установлен путь к публичному ключу
        <span class="cov8" title="1">crypto := config.GetCryptoGrapher()
        if crypto.PublicKeyIsSet() </span><span class="cov0" title="0">{
                compressBody, err = crypto.Encrypt(compressBody)
                if err != nil </span><span class="cov0" title="0">{
                        logger.AgentLog.Error("fail to encode compressed data ", zap.String("error", error.Error(err)))
                        return err
                }</span>
        }

        // Подписываю данные отправляемые на сервер
        // Делаю не через middleware, чтобы агент подписывал именно нескомпресированный ответ
        <span class="cov8" title="1">hash, err := repositories.CalkHash(bufEncode.Bytes(), hasher.GetKey())
        if err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Fail to calc hash ", zap.String("error", error.Error(err)))
                return err
        }</span>
        <span class="cov8" title="1">logger.AgentLog.Debug("body and hash for forwarding to server ", zap.String("body", fmt.Sprintf("%x", bufEncode.Bytes())),
                zap.String("hash", hash), zap.String("key", hasher.GetKey()))

        // получаю ip адрес хоста для передачи на сервер в заголовке X-Real-IP
        hostAddress, err := ipgetter.Get()
        if err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Fail to get host ip address ", zap.String("error", error.Error(err)))
                return err
        }</span>

        <span class="cov8" title="1">url := fmt.Sprintf("%s/%s", address, action)
        resp, err := client.R().
                SetHeader("Content-Type", "application/json").
                SetHeader("Content-Encoding", "gzip").
                SetHeader("Accept-Encoding", "gzip").
                SetHeader("HashSHA256", hash).
                SetHeader("X-Real-IP", hostAddress).
                SetBody(compressBody).
                Post(url)

        if err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Push json metric to server error ", zap.String("error", error.Error(err)))
                return err
        }</span>

        <span class="cov8" title="1">logger.AgentLog.Debug("Get answer from server", zap.String("Content-Encoding", resp.Header().Get("Content-Encoding")),
                zap.String("statusCode", fmt.Sprintf("%d", resp.StatusCode())),
                zap.String("Content-Type", resp.Header().Get("Content-Type")),
                zap.String("HashSHA256", resp.Header().Get("HashSHA256")),
                zap.String("Content-Encoding", fmt.Sprint(resp.Header().Values("Content-Encoding"))))

        if resp.StatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                logger.AgentLog.Error("Geting status is not 200 ", zap.String("statusCode", fmt.Sprintf("%d", resp.StatusCode())))
                return fmt.Errorf("status code is: %d %w", resp.StatusCode(), errors.New(resp.String()))
        }</span>

        <span class="cov8" title="1">contentEncoding := resp.Header().Get("Content-Encoding")
        if strings.Contains(contentEncoding, "gzip") </span><span class="cov8" title="1">{
                logger.AgentLog.Debug("Get compress answer data in PushJSON function", zap.String("Content-Encoding", contentEncoding))
        }</span> else<span class="cov0" title="0"> {
                logger.AgentLog.Debug("Get uncompress answer data in PushJSON function", zap.String("Content-Encoding", contentEncoding))
        }</span>

        <span class="cov8" title="1">responceMetric := resp.Body()
        if !bytes.Equal(bufEncode.Bytes(), responceMetric) </span><span class="cov0" title="0">{
                return fmt.Errorf("answer metric from server not equal pushing metric: get %d, want %d", responceMetric, bufEncode.Bytes())
        }</span>

        // Десериализую данные полученные от сервера, в основном для дебага
        <span class="cov8" title="1">var resJSON repositories.Metric
        buRes := bytes.NewBuffer(responceMetric)
        dec := json.NewDecoder(buRes)
        if err := dec.Decode(&amp;resJSON); err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("decode decompress data from server error ", zap.String("error", error.Error(err)))
                return err
        }</span>
        <span class="cov8" title="1">logger.AgentLog.Debug(fmt.Sprintf("decode metric from server %s", resJSON.String()))

        logger.AgentLog.Debug(fmt.Sprintf("Success push metric in JSON format: typeMetric - %s, nameMetric - %s, valueMetric - %s", typeMetric, nameMetric, valueMetric))
        return nil</span>
}

// Push отправляет метрику на сервер и возвращает ошибку при неудаче.
func Push(address, action, typemetric, namemetric, valuemetric string, client *resty.Client) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/%s/%s/%s/%s", address, action, typemetric, namemetric, valuemetric)

        // получаю ip адрес хоста для передачи на сервер в заголовке X-Real-IP
        hostAddress, err := ipgetter.Get()
        if err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Fail to get host ip address ", zap.String("error", error.Error(err)))
                return err
        }</span>

        <span class="cov8" title="1">resp, err := client.R().
                SetHeader("Content-Type", "text/plain").
                SetHeader("X-Real-IP", hostAddress).
                Post(url)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error with post: %s, %w", url, err)
        }</span>

        <span class="cov8" title="1">if resp.StatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                return fmt.Errorf("received non-200 response status: %d for url: %s", resp.StatusCode(), url)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// PushAll - отправляет все собранные метрики на сервер, поочередно отправляя каждую метрику по отдельности.
func PushAll(address, action string, metrics *storage.MetricsStats, client *resty.Client) <span class="cov0" title="0">{
        metrics.Lock()
        defer metrics.Unlock()

        for _, metricName := range storage.AllMetrics </span><span class="cov0" title="0">{
                typeMetric, value, err := metrics.GetMetricString(metricName)
                if err != nil </span><span class="cov0" title="0">{
                        logger.AgentLog.Error(fmt.Sprintf("Failed to get metric %s: %v\n", typeMetric, err), zap.String("action", "push metrics"))
                        continue</span>
                }
                <span class="cov0" title="0">er := PushJSON(address, action, typeMetric, metricName, value, client)
                if er != nil </span><span class="cov0" title="0">{
                        logger.AgentLog.Error(fmt.Sprintf("Failed to push metric %s: %v\n", typeMetric, er), zap.String("action", "push metrics"))
                }</span>
        }
}

// PushBatch - отправляет батч метрик на сервер.
func PushBatch(address, action string, metricsSlice []repositories.Metric, client *resty.Client) error <span class="cov8" title="1">{

        // сериализую полученную слайс с метриками в json-представление  в виде слайса байт
        var bufEncode bytes.Buffer
        enc := json.NewEncoder(&amp;bufEncode)
        if err := enc.Encode(metricsSlice); err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Encode message error", zap.String("error", error.Error(err)))
                return err
        }</span>

        // Сжатие данных для передачи
        <span class="cov8" title="1">compressBody, err := compress.Compress(bufEncode.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Fail to comperess push data ", zap.String("error", error.Error(err)))
                return err
        }</span>

        // Шифрование сжатых данных если установлен путь к публичному ключу
        <span class="cov8" title="1">crypto := config.GetCryptoGrapher()
        if crypto.PublicKeyIsSet() </span><span class="cov0" title="0">{
                compressBody, err = crypto.Encrypt(compressBody)
                if err != nil </span><span class="cov0" title="0">{
                        logger.AgentLog.Error("fail to encode compressed data ", zap.String("error", error.Error(err)))
                        return err
                }</span>
        }

        // Создаю контекст с таймаутом
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), config.GetContextTimeout())
        defer cancel()

        // Подписываю данные отправляемые на сервер
        // Делаю не через middleware, чтобы агент подписывал именно нескомпресированный ответ
        hash, err := repositories.CalkHash(bufEncode.Bytes(), hasher.GetKey())
        if err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Fail to calc hash ", zap.String("error", error.Error(err)))
                return err
        }</span>
        <span class="cov8" title="1">logger.AgentLog.Debug("body and hash for forwarding to server ", zap.String("body", fmt.Sprintf("%x", bufEncode.Bytes())),
                zap.String("hash", hash), zap.String("key", hasher.GetKey()))

        // получаю ip адрес хоста для передачи на сервер в заголовке X-Real-IP
        hostAddress, err := ipgetter.Get()
        if err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Fail to get host ip address ", zap.String("error", error.Error(err)))
                return err
        }</span>

        <span class="cov8" title="1">url := fmt.Sprintf("%s/%s", address, action)
        resp, err := client.R().
                SetHeader("Content-Type", "application/json").
                SetHeader("Content-Encoding", "gzip").
                SetHeader("Accept-Encoding", "gzip").
                SetHeader("HashSHA256", hash).
                SetHeader("X-Real-IP", hostAddress).
                SetBody(compressBody).
                SetContext(ctx).
                Post(url)

        if err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Push batch json metrics to server error ", zap.String("error", error.Error(err)))
                return err
        }</span>

        <span class="cov8" title="1">logger.AgentLog.Debug("Get answer from server", zap.String("Content-Encoding", resp.Header().Get("Content-Encoding")),
                zap.String("statusCode", fmt.Sprintf("%d", resp.StatusCode())),
                zap.String("Content-Type", resp.Header().Get("Content-Type")),
                zap.String("HashSHA256", resp.Header().Get("HashSHA256")),
                zap.String("Content-Encoding", fmt.Sprint(resp.Header().Values("Content-Encoding"))))

        if resp.StatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                logger.AgentLog.Error("Geting status is not 200 ", zap.String("statusCode", fmt.Sprintf("%d", resp.StatusCode())))
                return fmt.Errorf("status code is: %d %w", resp.StatusCode(), errors.New(resp.String()))
        }</span>
        <span class="cov0" title="0">contentEncoding := resp.Header().Get("Content-Encoding")
        if strings.Contains(contentEncoding, "gzip") </span><span class="cov0" title="0">{
                logger.AgentLog.Debug("Get compress answer data in PushBatch function", zap.String("Content-Encoding", contentEncoding))
        }</span> else<span class="cov0" title="0"> {
                logger.AgentLog.Debug("Get uncompress answer data in PushBatch function", zap.String("Content-Encoding", contentEncoding))
        }</span>

        <span class="cov0" title="0">responceMetrics := resp.Body()
        if !bytes.Equal(bufEncode.Bytes(), responceMetrics) </span><span class="cov0" title="0">{
                return fmt.Errorf("answer metric from server not equal pushing metric: get %d, want %d", responceMetrics, bufEncode.Bytes())
        }</span>

        // Десериализую данные полученные от сервера, в основном для дебага
        <span class="cov0" title="0">var resJSON []repositories.Metric
        buRes := bytes.NewBuffer(responceMetrics)
        dec := json.NewDecoder(buRes)
        if err := dec.Decode(&amp;resJSON); err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("decode decompress data from server error ", zap.String("error", error.Error(err)))
                return err
        }</span>

        <span class="cov0" title="0">logger.AgentLog.Debug("Success push batch metrics in JSON format")
        return nil</span>
}

// PrepareAndPushBatch - строит батч метрик и вызывает функцию для отправки батча на сервер в рамках одной передачи.
func PrepareAndPushBatch(address, action string, metrics *storage.MetricsStats, client *resty.Client) error <span class="cov8" title="1">{
        if metrics == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("metrics is not initialize")
        }</span>
        <span class="cov8" title="1">if client == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("resty client is not initialize")
        }</span>

        <span class="cov0" title="0">metrics.Lock()
        defer metrics.Unlock()

        // создаю слайс с метриками для отправки батчем
        metricsSlice := builder.BuildSlice(metrics)

        err := PushBatch(address, action, metricsSlice, client)
        if err != nil </span><span class="cov0" title="0">{
                logger.AgentLog.Error("Failed to push batch metrics", zap.String("action", "push metrics"), zap.String("error", error.Error(err)))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package storage

import (
        "fmt"
        "runtime"
        "strconv"
        "sync"
        "time"

        "github.com/shirou/gopsutil/v4/cpu"
        "github.com/shirou/gopsutil/v4/mem"
        "go.uber.org/zap"
        "golang.org/x/exp/rand"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/logger"
)

// GaugeMetrics - слайс метрик типа "gauge".
var GaugeMetrics []string

// AllMetrics - слайс метрик.
var AllMetrics []string

func init() <span class="cov8" title="1">{
        GaugeMetrics = []string{"Alloc", "BuckHashSys", "Frees", "GCCPUFraction", "GCSys", "HeapAlloc", "HeapIdle", "HeapInuse", "HeapObjects",
                "HeapReleased", "HeapSys", "LastGC", "Lookups", "MCacheInuse", "MCacheSys", "MSpanInuse", "MSpanSys", "Mallocs", "NextGC", "NumForcedGC", "NumGC",
                "OtherSys", "PauseTotalNs", "StackInuse", "StackSys", "Sys", "TotalAlloc", "TotalMemory", "FreeMemory", "CPUutilization1"}
        AllMetrics = []string{"Alloc", "BuckHashSys", "Frees", "GCCPUFraction", "GCSys", "HeapAlloc", "HeapIdle", "HeapInuse", "HeapObjects",
                "HeapReleased", "HeapSys", "LastGC", "Lookups", "MCacheInuse", "MCacheSys", "MSpanInuse", "MSpanSys", "Mallocs", "NextGC", "NumForcedGC", "NumGC",
                "OtherSys", "PauseTotalNs", "StackInuse", "StackSys", "Sys", "TotalAlloc", "TotalMemory", "FreeMemory", "CPUutilization1", "PollCount", "RandomValue"}
}</span>

// MetricsStats - структура для хранения метрик.
type MetricsStats struct {
        sync.Mutex
        runtime.MemStats
        PollCount       int64
        RandomValue     float64
        TotalMemory     float64
        FreeMemory      float64
        CPUutilization1 float64
}

func collectExtraMetrics(ch chan&lt;- map[string]float64) <span class="cov8" title="1">{
        res := make(map[string]float64, 0)

        v, err := mem.VirtualMemory()
        if err == nil </span><span class="cov8" title="1">{
                res["TotalMemory"] = float64(v.Total)
                res["FreeMemory"] = float64(v.Free)
        }</span> else<span class="cov0" title="0"> {
                logger.AgentLog.Error("collect memory metrics error by gopsutil package", zap.String("error", err.Error()))
        }</span>

        <span class="cov8" title="1">c, err := cpu.Percent(time.Second, true)
        if err == nil </span><span class="cov8" title="1">{
                res["CPUutilization1"] = float64(c[0])
        }</span> else<span class="cov0" title="0"> {
                logger.AgentLog.Error("collect cpu metrics error by gopsutil package", zap.String("error", err.Error()))
        }</span>
        <span class="cov8" title="1">ch &lt;- res</span>
}

// CollectMetrics - собирает метрики.
func (metrics *MetricsStats) CollectMetrics() <span class="cov8" title="1">{
        // Сбор дополнительных метрик в отдельной горутине
        extraM := make(chan map[string]float64, 1)
        go collectExtraMetrics(extraM)

        metrics.Lock()
        defer metrics.Unlock()

        metrics.PollCount = 1
        runtime.ReadMemStats(&amp;metrics.MemStats)

        extraMetrics := &lt;-extraM
        for name, value := range extraMetrics </span><span class="cov8" title="1">{
                switch name </span>{
                case "TotalMemory":<span class="cov8" title="1">
                        metrics.TotalMemory = value</span>
                case "FreeMemory":<span class="cov8" title="1">
                        metrics.FreeMemory = value</span>
                case "CPUutilization1":<span class="cov8" title="1">
                        metrics.CPUutilization1 = value</span>
                }
        }
}

// GetRandomMetricName - вспомогательная функция для генерации метрики "RandomValue"
func GetRandomMetricName() string <span class="cov8" title="1">{
        // Инициализируем случайный источник с текущим временем
        rand.Seed(uint64(time.Now().UnixNano()))
        // Выбираем случайный индекс
        randomIndex := rand.Intn(len(GaugeMetrics))
        // Выбираем случайный элемент
        return GaugeMetrics[randomIndex]
}</span>

// GetMetricString - возвращает тип и значение метрики в виде строки по имени метрики.
func (metrics *MetricsStats) GetMetricString(name string) (typeMetric, value string, err error) <span class="cov8" title="1">{
        switch name </span>{
        case "Alloc":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.Alloc, 10), nil</span>
        case "BuckHashSys":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.BuckHashSys, 10), nil</span>
        case "Frees":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.Frees, 10), nil</span>
        case "GCCPUFraction":<span class="cov8" title="1">
                return "gauge", strconv.FormatFloat(metrics.GCCPUFraction, 'f', 6, 64), nil</span>
        case "GCSys":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.GCSys, 10), nil</span>
        case "HeapAlloc":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.HeapAlloc, 10), nil</span>
        case "HeapIdle":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.HeapIdle, 10), nil</span>
        case "HeapInuse":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.HeapInuse, 10), nil</span>
        case "HeapObjects":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.HeapObjects, 10), nil</span>
        case "HeapReleased":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.HeapReleased, 10), nil</span>
        case "HeapSys":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.HeapSys, 10), nil</span>
        case "LastGC":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.LastGC, 10), nil</span>
        case "Lookups":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.Lookups, 10), nil</span>
        case "MCacheInuse":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.MCacheInuse, 10), nil</span>
        case "MCacheSys":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.MCacheSys, 10), nil</span>
        case "MSpanInuse":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.MSpanInuse, 10), nil</span>
        case "MSpanSys":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.MSpanSys, 10), nil</span>
        case "Mallocs":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.Mallocs, 10), nil</span>
        case "NextGC":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.NextGC, 10), nil</span>
        case "NumForcedGC":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(uint64(metrics.NumForcedGC), 10), nil</span>
        case "NumGC":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(uint64(metrics.NumGC), 10), nil</span>
        case "OtherSys":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.OtherSys, 10), nil</span>
        case "PauseTotalNs":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.PauseTotalNs, 10), nil</span>
        case "StackInuse":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.StackInuse, 10), nil</span>
        case "StackSys":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.StackSys, 10), nil</span>
        case "Sys":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.Sys, 10), nil</span>
        case "TotalAlloc":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(metrics.TotalAlloc, 10), nil</span>
        case "PollCount":<span class="cov8" title="1">
                return "counter", strconv.FormatUint(uint64(metrics.PollCount), 10), nil</span>
        case "RandomValue":<span class="cov8" title="1">
                return metrics.GetMetricString(GetRandomMetricName())</span>
        case "TotalMemory":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(uint64(metrics.TotalMemory), 10), nil</span>
        case "FreeMemory":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(uint64(metrics.FreeMemory), 10), nil</span>
        case "CPUutilization1":<span class="cov8" title="1">
                return "gauge", strconv.FormatUint(uint64(metrics.CPUutilization1), 10), nil</span>
        }

        <span class="cov8" title="1">return "", "", fmt.Errorf("metric %s is not exist", name)</span>
}

// NewMetricsStats - фабричная функция для создания структуры MetricsStats
func NewMetricsStats() *MetricsStats <span class="cov8" title="1">{
        return &amp;MetricsStats{}
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package worker

import (
        "context"
        "errors"
        "fmt"
        "sync"
        "time"

        "github.com/go-resty/resty/v2"
        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/errors/checker"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/hasher"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/logger"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/storage"
)

// PushFunction - тип функции выполняющей отправку метрики.
type PushFunction = func(string, string, *storage.MetricsStats, *resty.Client) error

// RetryExecPushFunction - для повторной отправки запроса в случае, если сервер не отвечает. Установлено три дополнительных попыток.
func RetryExecPushFunction(address, action string, metrics *storage.MetricsStats, client *resty.Client, pushFunction PushFunction) <span class="cov0" title="0">{
        sleepIntervals := []time.Duration{0, 1, 3, 5}

        for i := 0; i &lt; 4; i++ </span><span class="cov0" title="0">{
                logger.AgentLog.Debug(fmt.Sprintf("Push metrics to server, attemption %d", i+1))

                time.Sleep(sleepIntervals[i] * time.Second)

                err := pushFunction(address, action, metrics, client)
                if err != nil &amp;&amp; (errors.Is(err, context.DeadlineExceeded) ||
                        checker.IsConnectionRefused(err) ||
                        checker.IsDBTransportError(err)) ||
                        checker.IsFileLockedError(err) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> {
                        return
                }</span>
        }
}

// Task - структура для хранения всех необходимых параметров для отправки метрик.
// Реализация патерна worker pool.
type Task struct {
        address      string                // адрес отправки
        action       string                // http метод, например: POST
        metrics      *storage.MetricsStats // структура с собранными метриками
        pushFunction PushFunction          // функция, непосредственно выполняющая отправку
        restyClient  *resty.Client         // клиент resty
}

// NewTask - фабричная функция структуры Task.
func NewTask(address, action string, metrics *storage.MetricsStats, pushFunction PushFunction) *Task <span class="cov8" title="1">{
        return &amp;Task{
                address:      address,
                action:       action,
                metrics:      metrics,
                pushFunction: pushFunction,
                restyClient:  resty.New(),
        }
}</span>

// Do - метод для выполнения задачи.
func (t Task) Do() <span class="cov0" title="0">{
        // Добавляем middleware для обработки ответа
        t.restyClient.OnAfterResponse(hasher.VerifyHashMiddleware)

        RetryExecPushFunction(t.address, t.action, t.metrics, t.restyClient, t.pushFunction)
        logger.AgentLog.Debug("Running agent", zap.String("action", "push metrics"))
}</span>

// DoWork - принимает задачу из канала и выполняет её.
func DoWork(pushTasks &lt;-chan Task, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        for pushTask := range pushTasks </span><span class="cov0" title="0">{
                pushTask.Do()
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package agent

import (
        "context"
        "fmt"
        "log"
        "sync"

        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/logger"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/builder"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/storage"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/api/agent/impl"
)

// Worker - структура для реализации патерна worker pool.
type Worker struct {
        cl                 *impl.Client
        metrics            *storage.MetricsStats
        transmittionMethod string
        ctx                context.Context
}

// Do - метод для выполнения задачи.
func (w *Worker) Do() error <span class="cov8" title="1">{
        metricsSlice := builder.BuildSlice(w.metrics)

        switch w.transmittionMethod </span>{
        case "AddMetric":<span class="cov8" title="1">
                err := impl.AddMetric(w.ctx, w.cl, metricsSlice)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to send a message to the server with AddMetric method: %v", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown transmittion method")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// NewTask - фабричная функция структуры Worker.
func NewWorker(ctx context.Context, netAddr, transmittionMethod string, metrics *storage.MetricsStats) *Worker <span class="cov8" title="1">{
        cl, err := impl.InitClient(netAddr)
        // Если инициализация клиента завершилась ошибкой считаю это критической ошибкой, так как это мешает корректно запустить работу агента.
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to start grpc client %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;Worker{
                cl:                 cl,
                metrics:            metrics,
                transmittionMethod: transmittionMethod,
                ctx:                ctx,
        }</span>
}

// InitWorkerAndDo - создает воркера, принимает задачу из канала и выполняет её.
func InitWorkerAndDo(ctx context.Context, netAddr, transmittionMethod string, metrics *storage.MetricsStats, pushTasks &lt;-chan struct{}, wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()

        worker := NewWorker(ctx, netAddr, transmittionMethod, metrics)

        for range pushTasks </span><span class="cov8" title="1">{
                err := worker.Do()

                if err != nil </span><span class="cov8" title="1">{
                        logger.AgentLog.Error("do work error", zap.String("error", err.Error()))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package impl

import (
        "context"
        "fmt"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/encoding/gzip"
        "google.golang.org/grpc/status"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/logger"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/metrics/checker"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/api/agent/interceptors/hasher"
        pb "github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/protoc"
        pbModel "github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/protoc/model"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
)

// Client - структура для реализации proto интерфейса клиента.
type Client struct {
        pb.ServiceClient
        conn *grpc.ClientConn
}

// InitClient - функция для инициализации gRPC клиента.
func InitClient(netAddr string) (*Client, error) <span class="cov8" title="1">{
        logger.AgentLog.Info("initialize new grpc client", zap.String("netAddr", netAddr))

        opts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithDefaultCallOptions(grpc.UseCompressor(gzip.Name)),
                grpc.WithUnaryInterceptor(hasher.UnaryClientInterceptor),
        }

        conn, err := grpc.NewClient(netAddr, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create a new client: %w", err)
        }</span>
        <span class="cov8" title="1">client := pb.NewServiceClient(conn)

        return &amp;Client{
                conn:          conn,
                ServiceClient: client,
        }, err</span>
}

// AddMetric - функция для последовательной отправки метрик на сервер из слайса метрик.
func AddMetric(ctx context.Context, cl *Client, metricsSlice []repositories.Metric) error <span class="cov8" title="1">{
        logger.AgentLog.Info("send metrics from slice to server")

        if metricsSlice == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("metric slice is nil")
        }</span>

        <span class="cov8" title="1">for _, metric := range metricsSlice </span><span class="cov8" title="1">{
                m := pbModel.Metric{
                        Id:    metric.ID,
                        Mtype: metric.MType,
                        Delta: metric.Delta,
                        Value: metric.Value,
                }
                req := pbModel.AddMetricRequest{
                        Metric: &amp;m,
                }
                // Вызов grpc метода. В этом месте можно установить необходимые перехватчики.
                resp, err := cl.AddMetric(ctx, &amp;req)
                if err != nil </span><span class="cov8" title="1">{
                        if e, ok := status.FromError(err); ok </span><span class="cov8" title="1">{
                                return fmt.Errorf("error of add metric to server: %v", e.Message())
                        }</span> else<span class="cov0" title="0"> {
                                return fmt.Errorf("error of add metric to server, can't parse error: %v", err)
                        }</span>
                }
                <span class="cov8" title="1">if resp.Error != nil &amp;&amp; *resp.Error != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("error of add metric to server, error from server response: %s", *resp.Error)
                }</span>

                // Проверяю ответ сервера. Сравниваю метрику отправленную на сервер с метрикой, которую сервер вернул.
                <span class="cov8" title="1">if resp.Metric == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("metric from server is nil in grpc.AddMetric")
                }</span>
                <span class="cov8" title="1">if !checker.Equal(metric, repositories.Metric{
                        ID:    resp.Metric.Id,
                        MType: resp.Metric.Mtype,
                        Delta: resp.Metric.Delta,
                        Value: resp.Metric.Value,
                }) </span><span class="cov0" title="0">{
                        return fmt.Errorf("metric from server is not equal request metric")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package hasher

import (
        "context"
        "fmt"

        "go.uber.org/zap"
        "google.golang.org/protobuf/proto"

        httpHasher "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/hasher"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/agent/logger"
        serverHasher "github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/api/server/interceptors/hasher"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/protoc/model"

        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
)

// UnaryClientInterceptor - перехватчик клиента для подписи данных и проверки подписи ответа сервера, если установлен ключ.
func UnaryClientInterceptor(ctx context.Context, method string, req, reply interface{},
        cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error <span class="cov8" title="1">{

        // секретный ключ для подписи данных
        secretKey := httpHasher.GetKey()
        // если ключ не установлен, подписыать данные и проверять подпись ответа сервера не нужно
        if secretKey == "" </span><span class="cov8" title="1">{
                return invoker(ctx, method, req, reply, cc, opts...)
        }</span>

        // Подпись запроса клиента------------------------------------------------------
        <span class="cov8" title="1">switch r := req.(type) </span>{
        case *model.AddMetricRequest:<span class="cov8" title="1">
                // подписываю запрос
                outgoingCtx, err := SetHash(ctx, r, secretKey)
                if err != nil </span><span class="cov0" title="0">{
                        logger.AgentLog.Error("failed to hash request", zap.String("method: ", method), zap.String("error: ", error.Error(err)))
                        return fmt.Errorf("failed to hash request %v", err)
                }</span>
                <span class="cov8" title="1">ctx = outgoingCtx</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("failed to hash request, unknown request type")</span>
        }

        // вызываем RPC-метод--------------------------------
        // для получения метаданных от сервера
        <span class="cov8" title="1">var header metadata.MD
        err := invoker(ctx, method, req, reply, cc, append(opts, grpc.Header(&amp;header))...)
        if err != nil </span><span class="cov8" title="1">{
                logger.AgentLog.Error("invoke grpc method error", zap.String("method: ", method), zap.String("error: ", error.Error(err)))
                return err
        }</span>

        // Проверка подписи ответа сервера----------------------------------------------------
        <span class="cov8" title="1">reqHashes := header.Get("HashSHA256")
        if len(reqHashes) == 0 </span><span class="cov0" title="0">{
                // хэш не установлен
                return fmt.Errorf("hash is not set in server response")
        }</span>

        // извлечение ответа сервера и проверка подписи
        <span class="cov8" title="1">switch r := reply.(type) </span>{
        case *model.AddMetricResponce:<span class="cov8" title="1">
                ok, err := serverHasher.CheckHash(r, reqHashes[0], httpHasher.GetKey())
                if err != nil </span><span class="cov8" title="1">{
                        logger.AgentLog.Error("checking hash error", zap.String("method: ", method), zap.String("error: ", error.Error(err)))
                        return fmt.Errorf("checking hash error: %v", err)
                }</span>
                <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                        logger.AgentLog.Error("hashs is not equal", zap.String("method: ", method))
                        return fmt.Errorf("hashs is not equal")
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("failed to serialize response, unknown request type")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SetHash - вспомогательная функция подписи запроса у установки хэша в контекст.
func SetHash(ctx context.Context, req proto.Message, secretKey string) (context.Context, error) <span class="cov8" title="1">{
        // подписываю запрос
        hash, err := serverHasher.CalkHash(req, secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash request %v", err)
        }</span>
        // Добавляю хэш в метаданные
        <span class="cov8" title="1">md := metadata.New(map[string]string{"HashSHA256": hash})
        outgoingCtx := metadata.NewOutgoingContext(ctx, md)
        return outgoingCtx, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package impl

import (
        "context"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        pb "github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/protoc"
        pbModel "github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/protoc/model"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
)

// Server - структура для реализации proto интерфейса сервера.
type Server struct {
        pb.UnimplementedServiceServer
        storage repositories.IStorage
}

// NewServer - фабричная функция структуры Server.
func NewServer(stor repositories.IStorage) *Server <span class="cov8" title="1">{
        return &amp;Server{
                storage: stor,
        }
}</span>

// AddMetric - gRPC метод для добавления метрики на сервер.
func (s *Server) AddMetric(ctx context.Context, req *pbModel.AddMetricRequest) (*pbModel.AddMetricResponce, error) <span class="cov8" title="1">{
        responce := &amp;pbModel.AddMetricResponce{}

        // Проверка на nil для хранилище сервера
        if s.storage == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Internal, "storage not initialized")
        }</span>
        <span class="cov8" title="1">if req.Metric == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "metric in request is nil")
        }</span>
        <span class="cov8" title="1">metric := req.Metric

        // загрузка метрики в хранилище сервера
        switch metric.Mtype </span>{
        case "gauge":<span class="cov8" title="1">
                if metric.Value == nil </span><span class="cov8" title="1">{
                        logger.ServerGRPCLog.Error("Decode message error, value in gauge metric is nil")
                        return nil, status.Error(codes.InvalidArgument, "decode message error, value in gauge metric is nil")
                }</span>
                <span class="cov8" title="1">err := s.storage.AddGauge(ctx, metric.Id, *metric.Value)
                if err != nil </span><span class="cov0" title="0">{
                        logger.ServerGRPCLog.Error("add gauge error", zap.String("error", error.Error(err)))
                        return nil, status.Error(codes.Internal, "add gauge error")
                }</span>
        case "counter":<span class="cov8" title="1">
                if metric.Delta == nil </span><span class="cov8" title="1">{
                        logger.ServerGRPCLog.Error("Decode message error, delta in counter metric is nil")
                        return nil, status.Error(codes.InvalidArgument, "decode message error, delta in counter metric is nil")
                }</span>
                <span class="cov8" title="1">err := s.storage.AddCounter(ctx, metric.Id, *metric.Delta)
                if err != nil </span><span class="cov0" title="0">{
                        logger.ServerGRPCLog.Error("add counter error", zap.String("error", error.Error(err)))
                        return nil, status.Error(codes.Internal, "add counter error")
                }</span>
        default:<span class="cov8" title="1">
                logger.ServerGRPCLog.Error("Invalid type of metric", zap.String("type", metric.Mtype))
                return nil, status.Errorf(codes.InvalidArgument, "invalid type of metric, type %s", metric.Mtype)</span>
        }
        <span class="cov8" title="1">logger.ServerGRPCLog.Debug("Successful decode metrcic from json")

        // возвращаю клиенту туже метрику, которую он отправил на сервер
        // в случае успешного добавления метрики на сервере
        responce.Metric = req.Metric
        return responce, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package hasher

import (
        "context"
        "fmt"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/grpc/protoc/model"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
        httpHasher "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/hasher"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
)

// UnaryServerInterceptor - перехватчик для проверки подписи и подписи данных, если установлен ключ.
func UnaryServerInterceptor(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp any, err error) <span class="cov8" title="1">{
        // Если не сервере не задан секретный ключ для подписи данных, то эта операция не производится
        if k := httpHasher.GetKey(); k == "" </span><span class="cov8" title="1">{
                // вызываю основной обработчик без изменений и преобразований
                return handler(ctx, req)
        }</span>

        // О необходимости такого поведения понял из тестов -------------------------------------------------------------------
        // Метаданные получаю из контекста
        <span class="cov8" title="1">md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "hasher error: metadata not set to context")
        }</span>

        <span class="cov8" title="1">if noneHash := md.Get("Hash"); len(noneHash) &gt; 0 &amp;&amp; noneHash[0] == "none" </span><span class="cov8" title="1">{
                // вызываю основной обработчик без изменений и преобразований
                return handler(ctx, req)
        }</span>

        <span class="cov8" title="1">reqHashs := md.Get("HashSHA256")
        if len(reqHashs) == 0 </span><span class="cov8" title="1">{
                // вызываю основной обработчик без изменений и преобразований
                return handler(ctx, req)
        }</span>

        // проверка подписи в случае непустого тела запроса ------------------------------------------------------------------
        <span class="cov8" title="1">if req != nil </span><span class="cov8" title="1">{
                // извлечение сообщения от сервера и проверка подписи
                switch r := req.(type) </span>{
                case *model.AddMetricRequest:<span class="cov8" title="1">
                        ok, err := CheckHash(r, reqHashs[0], httpHasher.GetKey())
                        if err != nil </span><span class="cov8" title="1">{
                                logger.ServerLog.Error("checking hash error", zap.String("error: ", error.Error(err)))
                                return nil, status.Errorf(codes.Internal, "checking hash error: %v", err)
                        }</span>
                        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                                logger.ServerLog.Error("hashs is not equal")
                                return nil, status.Error(codes.InvalidArgument, "hashs is not equal")
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, status.Error(codes.InvalidArgument, "failed to serialize request, unknown request type")</span>
                }
        }

        // Подписываю ответ сервера в случае, если задан ключ---------------------------------------------
        // вызываю основной обработчик
        <span class="cov8" title="1">resp, err = handler(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Подписываю ответ сервера
        <span class="cov8" title="1">switch r := resp.(type) </span>{
        case *model.AddMetricResponce:<span class="cov8" title="1">
                // подписываю ответ сервера
                hash, err := CalkHash(r, httpHasher.GetKey())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Internal, "failed to hash response %v", err)
                }</span>
                // Добавляю хэш в метаданные
                <span class="cov8" title="1">if err := grpc.SetHeader(ctx, metadata.Pairs("HashSHA256", hash)); err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Internal, "failed to set response hash: %v", err)
                }</span>
        default:<span class="cov0" title="0">
                return nil, status.Error(codes.Internal, "failed to hash response, unknown response type")</span>
        }
        <span class="cov8" title="1">return</span>
}

// CalkHash - вспомогательная функция для вычисления хэша из proto сообщения с помощью секретного ключа.
func CalkHash(resp proto.Message, key string) (string, error) <span class="cov8" title="1">{
        // Сериализация protoc сообщения в байты
        body, err := proto.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to serialize response: %v", err)
        }</span>
        // вычисление хэша
        <span class="cov8" title="1">res, err := repositories.CalkHash(body, key)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to hash response, error: %v", err)
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}

// CheckHash - вспомогательная функция для проверки переданного хэша и расчитанного из proto сообщения
// используя секретный ключ.
func CheckHash(resp proto.Message, wantHash, key string) (bool, error) <span class="cov8" title="1">{
        // Сериализация protoc сообщения в байты
        body, err := proto.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to serialize request: %v", err)
        }</span>

        <span class="cov8" title="1">ok, err := repositories.CheckHash(body, wantHash, key)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("checking hash error: %v", err)
        }</span>
        <span class="cov8" title="1">return ok, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package ipfilter

import (
        "context"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/peer"
        "google.golang.org/grpc/status"

        httpIpfilter "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/ipfilter"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/ipchecker"
)

// UnaryServerInterceptor - перехватчик проверки вхождения ip адреса клиента в доверенную сеть сервера. Ip адрес извлекается из заголовка контекста.
// Проверка осуществляется только в случае, если установлена переменная trustedSubnet.
func UnaryServerInterceptor(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp any, err error) <span class="cov8" title="1">{
        subnet := httpIpfilter.GetTrustedSubnet()

        // проверяю вхождение Ip адреса в доверенную сеть только в том случае, если установлена переменная trustedSubnet
        if subnet != "" </span><span class="cov8" title="1">{
                // Извлекаем информацию о клиенте
                p, ok := peer.FromContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.PermissionDenied, "unable to get client IP")
                }</span>

                // Получаем адрес клиента (включая порт, например "192.168.1.10:12345")
                <span class="cov8" title="1">realIP := p.Addr.String()
                logger.ServerLog.Debug("real ip of agent host is", zap.String("realip", realIP))

                // проверка вхождения ip в доверенную сеть
                intrusted, err := ipchecker.InTrustedSubNet(subnet, realIP)
                if err != nil </span><span class="cov8" title="1">{
                        logger.ServerLog.Error("in trusted subNet check error", zap.String("error", error.Error(err)))
                        return nil, status.Error(codes.Internal, "in trusted subNet check error")
                }</span>
                <span class="cov8" title="1">if !intrusted </span><span class="cov8" title="1">{
                        logger.ServerLog.Info("ip of agent is not in trusted sub net")
                        return nil, status.Error(codes.PermissionDenied, "ip of agent is not in trusted sub net")
                }</span>
        }

        // вызываю основной обработчик
        <span class="cov8" title="1">return handler(ctx, req)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright (c) The go-grpc-middleware Authors.
// Licensed under the Apache License 2.0.

package logger

import (
        "context"
        "fmt"

        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
        "go.uber.org/zap"
)

// InterceptorLogger adapts zap logger to interceptor logger.
// This code is simple enough to be copied and not imported.
func Logger(l *zap.Logger) logging.Logger <span class="cov0" title="0">{
        return logging.LoggerFunc(func(ctx context.Context, lvl logging.Level, msg string, fields ...any) </span><span class="cov0" title="0">{
                f := make([]zap.Field, 0, len(fields)/2)

                for i := 0; i &lt; len(fields); i += 2 </span><span class="cov0" title="0">{
                        key := fields[i]
                        value := fields[i+1]

                        switch v := value.(type) </span>{
                        case string:<span class="cov0" title="0">
                                f = append(f, zap.String(key.(string), v))</span>
                        case int:<span class="cov0" title="0">
                                f = append(f, zap.Int(key.(string), v))</span>
                        case bool:<span class="cov0" title="0">
                                f = append(f, zap.Bool(key.(string), v))</span>
                        default:<span class="cov0" title="0">
                                f = append(f, zap.Any(key.(string), v))</span>
                        }
                }

                <span class="cov0" title="0">logger := l.WithOptions(zap.AddCallerSkip(1)).With(f...)

                switch lvl </span>{
                case logging.LevelDebug:<span class="cov0" title="0">
                        logger.Debug(msg)</span>
                case logging.LevelInfo:<span class="cov0" title="0">
                        logger.Info(msg)</span>
                case logging.LevelWarn:<span class="cov0" title="0">
                        logger.Warn(msg)</span>
                case logging.LevelError:<span class="cov0" title="0">
                        logger.Error(msg)</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("unknown level %v", lvl))</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package repositories

import (
        "compress/gzip"
        "io"
        "net/http"
)

// CompressWriter реализует интерфейс http.ResponseWriter и позволяет прозрачно для сервера
// сжимать передаваемые данные и выставлять правильные HTTP-заголовки.
type CompressWriter struct {
        w  http.ResponseWriter
        zw *gzip.Writer
}

// NewCompressWriter - фабричная функция для создания структуры CompressWriter.
func NewCompressWriter(w http.ResponseWriter) *CompressWriter <span class="cov8" title="1">{
        return &amp;CompressWriter{
                w:  w,
                zw: gzip.NewWriter(w),
        }
}</span>

// Header - установка заголовка.
func (c *CompressWriter) Header() http.Header <span class="cov8" title="1">{
        return c.w.Header()
}</span>

// Write - запись ответа.
func (c *CompressWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        // Устанавливаю заголовок о том, что данные сжаты, в основном на случай, когда в теле ответа будет содержаться ошибка
        // и агенту нужно будет корректно распаковать полученное от сервера тело с ошибкой
        c.w.Header().Set("Content-Encoding", "gzip")

        return c.zw.Write(p)
}</span>

// WriteHeader - установка заголовка.
func (c *CompressWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        // Устанавливаю заголовок о том, что данные сжаты, в основном на случай, когда в теле ответа будет содержаться ошибка
        // и агенту нужно будет корректно распаковать полученное от сервера тело с ошибкой
        c.w.Header().Set("Content-Encoding", "gzip")

        c.w.WriteHeader(statusCode)
}</span>

// Close закрывает gzip.Writer и досылает все данные из буфера.
func (c *CompressWriter) Close() error <span class="cov8" title="1">{
        return c.zw.Close()
}</span>

// CompressReader реализует интерфейс io.ReadCloser и позволяет прозрачно для сервера
// декомпрессировать получаемые от клиента данные.
type CompressReader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

// NewCompressReader - фабричная функци для создания структуры CompressReader.
func NewCompressReader(r io.ReadCloser) (*CompressReader, error) <span class="cov8" title="1">{
        zr, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;CompressReader{
                r:  r,
                zr: zr,
        }, nil</span>
}

// Read - метод чтения.
func (c CompressReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return c.zr.Read(p)
}</span>

// Close - обертка над gzip.Reader_Close.
func (c *CompressReader) Close() error <span class="cov8" title="1">{
        if err := c.r.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return c.zr.Close()</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package repositories

import (
        "encoding/json"
        "time"
)

// Duration оборачивает time.Duration для кастомной десериализации
type Duration struct {
        time.Duration
}

// UnmarshalJSON реализует кастомный Unmarshal для Duration
func (d *Duration) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        // Убираем кавычки и парсим как строку
        var s string
        if err := json.Unmarshal(b, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Парсим в time.Duration
        <span class="cov8" title="1">duration, err := time.ParseDuration(s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">d.Duration = duration
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repositories

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "net/http"

        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
)

// CalkHash - подписывает данные body алгоритмом SHA-256 с помощью ключа key.
func CalkHash(body []byte, key string) (string, error) <span class="cov8" title="1">{
        h := hmac.New(sha256.New, []byte(key))
        _, err := h.Write(body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">hash := h.Sum(nil)

        // Преобразуем хэш в строку
        hashStr := hex.EncodeToString(hash[:])
        return hashStr, nil</span>
}

// CheckHash - проверяет корректность подписи.
func CheckHash(body []byte, wantHash, key string) (bool, error) <span class="cov8" title="1">{
        logger.ServerLog.Debug("getting body and hash to check in CheckHash", zap.String("body", fmt.Sprintf("%x", body)), zap.String("hash", wantHash),
                zap.String("key", key))

        reqHashBytes, err := hex.DecodeString(wantHash)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("decode wantHash from string to []byte error: %v", err)
        }</span>

        // подписываем алгоритмом HMAC, используя SHA-256
        <span class="cov8" title="1">h := hmac.New(sha256.New, []byte(key))
        _, err = h.Write(body)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("error of hashing body %x with key %s by SHA-256: %v", body, key, err)
        }</span>
        <span class="cov8" title="1">hash := h.Sum(nil)

        if !hmac.Equal(hash, reqHashBytes) </span><span class="cov8" title="1">{
                logger.ServerLog.Debug("hashs is not equal", zap.String("want", fmt.Sprintf("%x", reqHashBytes)), zap.String("get", fmt.Sprintf("%x", hash)))
                return false, nil
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

// HashWriter реализует интерфейс http.ResponseWriter и позволяет прозрачно для сервера
// получить тело ответа для последующей подписи, если на сервере задан ключ
type HashWriter struct {
        w   http.ResponseWriter
        key string
}

// NewHashWriter - фабричная функция для создания структуры HashWriter.
func NewHashWriter(w http.ResponseWriter, key string) *HashWriter <span class="cov8" title="1">{
        return &amp;HashWriter{
                w:   w,
                key: key,
        }
}</span>

// Header - обертка над http.ResponseWriter_Header.
func (h *HashWriter) Header() http.Header <span class="cov8" title="1">{
        return h.w.Header()
}</span>

// Write - обертка над http.ResponseWriter_Write.
func (h *HashWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        hash, err := CalkHash(p, h.key)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        // Устанавливаю заголовок о подписи данных и результат подписи хэша
        <span class="cov8" title="1">h.w.Header().Set("HashSHA256", hash)

        logger.ServerLog.Debug("calculated hash in Write method", zap.String("hash", hash), zap.String("size of p", fmt.Sprintf("%d", len(p))),
                zap.String("body", fmt.Sprintf("%x", p)))

        return h.w.Write(p)</span>
}

// WriteHeader - обертка над http.ResponseWriter_WriteHeader.
func (h *HashWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        h.w.WriteHeader(statusCode)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package repositories

import (
        "context"
        "fmt"
)

// Интерфесы хранилища метрик.
type (
        // MetricsReader - интерфейс для получения метрик из хранилища.
        MetricsReader interface {
                GetMetric(ctx context.Context, typeMetric string, nameMetric string) (string, error) // Метод для получения метрики по типу и имени метрики.
                GetAllMetrics(context.Context) (string, error)                                       // Возвращает все хранимые в сервисе метрики в виде строки
                GetAllMetricsSlice(context.Context) ([]Metric, error)                                // Возвращает все хранимые в сервисе метрики в виде слайса метрик
        }

        // MetricsWriter - интерфейс для добавления метрик в хранилище.
        MetricsWriter interface {
                AddGauge(context.Context, string, float64) error     // Добавлеет в сервис новую метрики типа "gauge"
                AddCounter(context.Context, string, int64) error     // Добавлеет в сервис новую метрики типа "counter"
                AddMetricsFromSlice(context.Context, []Metric) error // Добавляет в сервис метрики из слайса метрик
        }

        // StorageStarter - интерфейс для инициализации хранилища.
        StorageStarter interface {
                Bootstrap(context.Context) error // Инициализирует хранилище метрик
        }

        // IStorage - полный интерфейс храненилища метрик.
        IStorage interface {
                MetricsReader
                MetricsWriter
                StorageStarter
        }

        // Metric - структура для работы с метриками json формата
        Metric struct {
                ID    string   `json:"id"`              // имя метрики
                MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
                Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
                Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
        }
)

// String возвращает представление метрики в виде строки
func (metrcic Metric) String() string <span class="cov8" title="1">{
        var delta = "nil"
        if metrcic.Delta != nil </span><span class="cov8" title="1">{
                delta = fmt.Sprintf("%d", *metrcic.Delta)
        }</span>
        <span class="cov8" title="1">var value = "nil"
        if metrcic.Value != nil </span><span class="cov8" title="1">{
                value = fmt.Sprintf("%g", *metrcic.Value)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("ID: %s, MType: %s, Delta: %s, Value: %s", metrcic.ID, metrcic.MType, delta, value)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Packet compress implement middleware for substitute origin responseWriter to
// responseWriter supporting compress if client support compressing.
package compress

import (
        "net/http"
        "slices"
        "strings"

        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
)

var contentTypes = []string{
        "application/json",
        "text/html",
        "",
}

// GzipMiddleware - мидлварь для замены оригинального http.ResponseWriter на ResponseWriter сжимающий данные,
// если клиент поддерживает сжатие.
func GzipMiddleware(h http.HandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // по умолчанию устанавливаем оригинальный http.ResponseWriter как тот,
                // который будем передавать следующей функции
                ow := w

                // проверяем, что клиент умеет получать от сервера сжатые данные в формате gzip
                acceptEncoding := r.Header.Get("Accept-Encoding")
                supportsGzip := strings.Contains(acceptEncoding, "gzip")
                contentType := r.Header.Get("Content-Type")
                if supportsGzip &amp;&amp; slices.Contains(contentTypes, contentType) </span><span class="cov8" title="1">{
                        logger.ServerLog.Debug("client accept encoding, compress answer data", zap.String("Accept-Encoding", acceptEncoding),
                                zap.String("Content-Type", contentType))
                        // оборачиваем оригинальный http.ResponseWriter новым с поддержкой сжатия
                        cw := repositories.NewCompressWriter(w)
                        // меняем оригинальный http.ResponseWriter на новый
                        ow = cw
                        // не забываем отправить клиенту все сжатые данные после завершения middleware
                        defer cw.Close()
                }</span>

                // проверяем, что клиент отправил серверу сжатые данные в формате gzip
                <span class="cov8" title="1">contentEncoding := r.Header.Get("Content-Encoding")
                sendsGzip := strings.Contains(contentEncoding, "gzip")
                if sendsGzip </span><span class="cov8" title="1">{
                        logger.ServerLog.Debug("client push encoding data, needed decompress", zap.String("Content-Encoding", contentEncoding))
                        // оборачиваем тело запроса в io.Reader с поддержкой декомпрессии
                        cr, err := repositories.NewCompressReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        // меняем тело запроса на новое
                        <span class="cov8" title="1">r.Body = cr
                        defer cr.Close()</span>
                }

                // передаём управление хендлеру
                <span class="cov8" title="1">h.ServeHTTP(ow, r)</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package config

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
)

// Configs представляет структуру конфигурации.
type Configs struct {
        Address       string                `json:"address"`        // аналог переменной окружения ADDRESS или флага -a
        GRPCAddress   string                `json:"grpc_address"`   // аналог переменной окружения GRPC_ADDRESS или флага -grpc-address
        LogLevel      string                `json:"log_level"`      // аналог переменной окружения SERVER_LOG_LEVEL или флага -l
        Restore       bool                  `json:"restore"`        // аналог переменной окружения RESTORE или флага -r
        StoreInterval repositories.Duration `json:"store_interval"` // аналог переменной окружения STORE_INTERVAL или флага -i
        StoreFile     string                `json:"store_file"`     // аналог переменной окружения FILE_STORAGE_PATH или -f
        DatabaseDSN   string                `json:"database_dsn"`   // аналог переменной окружения DATABASE_DSN или флага -d
        CryptoKey     string                `json:"crypto_key"`     // аналог переменной окружения CRYPTO_KEY или флага -crypto-key
        TrustedSubnet string                `json:"trusted_subnet"` // аналог переменной окружения TRUSTED_SUBNET или флага -t
}

// ParseConfigFile - функция для переопределения параметров конфигурации из файла конфигурации.
func ParseConfigFile(configFileNAme string) (Configs, error) <span class="cov8" title="1">{
        var configs Configs
        f, err := os.Open(configFileNAme)
        if err != nil </span><span class="cov0" title="0">{
                return Configs{}, fmt.Errorf("open cofiguration file error: %w", err)
        }</span>
        <span class="cov8" title="1">reader := bufio.NewReader(f)
        dec := json.NewDecoder(reader)
        err = dec.Decode(&amp;configs)
        if err != nil </span><span class="cov0" title="0">{
                return Configs{}, fmt.Errorf("parse cofiguration file error: %w", err)
        }</span>

        <span class="cov8" title="1">return configs, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package encrypt

import (
        "bytes"
        "io"
        "net/http"

        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/encryption"
)

// переменная, которая хранит структуру шифрования и расшифровки
var cryptoGrapher encryption.Cryptographer

// SetCryptoGrapher - функция для установки структуры шифрования и расшифровки данных
func SetCryptoGrapher(c *encryption.Cryptographer) <span class="cov8" title="1">{
        cryptoGrapher = *c
}</span>

// Middleware - мидлварь, которая расшифровывает данные от агента.
func Middleware(h http.HandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // если установлен адрес к приватному ключу предполагается, что используется шифрование данных
                if cryptoGrapher.PrivateKeyIsSet() </span><span class="cov8" title="1">{
                        // Чтение зашифрованного тела запроса
                        encryptedData, err := io.ReadAll(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.ServerLog.Error("read encrypted body error", zap.String("error", error.Error(err)))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">defer r.Body.Close()

                        decryptedData, err := cryptoGrapher.Decrypt(encryptedData)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.ServerLog.Error("decrypt data error", zap.String("error", error.Error(err)))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>

                        // Создание нового тела запроса с расшифрованными данными
                        <span class="cov8" title="1">r.Body = io.NopCloser(bytes.NewReader(decryptedData))</span>
                }
                // передаём управление хендлеру
                <span class="cov8" title="1">h.ServeHTTP(w, r)</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Packet handlers contain endpoints of interaction with service.
package handlers

import (
        "database/sql"
        "encoding/json"
        "html/template"
        "io"
        "log"
        "net/http"
        "strconv"

        "github.com/go-chi/chi/v5"
        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
)

var (
        tmpl *template.Template
)

// Парсин шаблона для вывода всех метрик в виде html страницы.
func init() <span class="cov8" title="1">{
        tmpl = template.Must(template.New("example").Parse(`
        &lt;!DOCTYPE html&gt;
        &lt;html lang="en"&gt;
        &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;title&gt;HTML Response&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;pre&gt;{{.}}&lt;/pre&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    `))
}</span>

// OtherRequest - обработка нераспознанных http запросов к сервису.
func OtherRequest(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        res.Header().Set("Content-Type", "text/plain")
        res.WriteHeader(http.StatusNotFound)
}</span>

// GetGlobal - возвращаю все хранящие на сервере метрики в виде html страницы.
func GetGlobal(res http.ResponseWriter, req *http.Request, storage repositories.MetricsReader) <span class="cov8" title="1">{
        res.Header().Set("Content-Type", "text/html")

        // устанавливаю заголовок таким образом вместо WriteHeader(http.StatusOK), потому что
        // далее в методе Write в middleware необходимо установить заголовок Hash со значением хэша,
        // а после WriteHeader заголовки уже не устанавливаются
        res.Header().Set("Status-Code", "200")
        metrics, err := storage.GetAllMetrics(req.Context())

        if err != nil </span><span class="cov8" title="1">{
                logger.ServerLog.Error("get all metrics error in GetGlobal handler", zap.String("error", error.Error(err)))
                http.Error(res, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if err := tmpl.Execute(res, metrics); err != nil </span><span class="cov8" title="1">{
                logger.ServerLog.Error("template execute error in GetGlobal handler", zap.String("error", error.Error(err)))
                res.WriteHeader(http.StatusInternalServerError)
                return
        }</span>
}

// PingDatabase - проверка связи с базой данных.
func PingDatabase(res http.ResponseWriter, req *http.Request, db *sql.DB) <span class="cov8" title="1">{
        if err := db.PingContext(req.Context()); err != nil </span><span class="cov8" title="1">{
                logger.ServerLog.Error("fail to ping database", zap.String("error", error.Error(err)))
                http.Error(res, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}

// GetMetricJSON - возвращает метрику в json представлении.
func GetMetricJSON(res http.ResponseWriter, req *http.Request, storage repositories.MetricsReader) <span class="cov8" title="1">{
        logger.ServerLog.Debug("In GetMetricJSON", zap.String("address", req.URL.String()))

        res.Header().Set("Content-Type", "application/json")

        defer req.Body.Close()

        var metrics repositories.Metric
        if err := json.NewDecoder(req.Body).Decode(&amp;metrics); err != nil </span><span class="cov8" title="1">{
                logger.ServerLog.Error("In GetMetricJSON decode body error", zap.String("address", req.URL.String()), zap.String("error", error.Error(err)))
                http.Error(res, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">metricType := metrics.MType
        metricName := metrics.ID

        value, err := storage.GetMetric(req.Context(), metricType, metricName)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(res, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">switch metricType </span>{
        case "counter":<span class="cov8" title="1">
                val, err := strconv.ParseInt(value, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        logger.ServerLog.Error("Convert string to int64 error: ", zap.String("address", req.URL.String()), zap.String("error: ", error.Error(err)))
                        http.Error(res, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">metrics.Delta = &amp;val</span>
        case "gauge":<span class="cov8" title="1">
                val, err := strconv.ParseFloat(value, 64)
                if err != nil </span><span class="cov8" title="1">{
                        logger.ServerLog.Error("Convert string to float64 error: ", zap.String("address", req.URL.String()), zap.String("error: ", error.Error(err)))
                        http.Error(res, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">metrics.Value = &amp;val</span>
        default:<span class="cov8" title="1">
                logger.ServerLog.Debug("In GetMetricJSON invalid type of metric", zap.String("address", req.URL.String()))
                res.WriteHeader(http.StatusBadRequest)
                return</span>
        }

        // устанавливаю заголовок таким образом вместо WriteHeader(http.StatusOK), потому что
        // далее в методе Write в middleware необходимо установить заголовок Hash со значением хэша,
        // а после WriteHeader заголовки уже не устанавливаются
        <span class="cov8" title="1">res.Header().Set("Status-Code", "200")
        enc := json.NewEncoder(res)
        if err := enc.Encode(metrics); err != nil </span><span class="cov0" title="0">{
                logger.ServerLog.Error("error encoding response", zap.String("error", error.Error(err)))
                return
        }</span>
}

// GetMetric - возвращает метрику в виде строки.
func GetMetric(res http.ResponseWriter, req *http.Request, storage repositories.MetricsReader) <span class="cov8" title="1">{
        logger.ServerLog.Debug("in GetMetric handler", zap.String("address", req.URL.String()))

        res.Header().Set("Content-Type", "text/plan")
        metricType := chi.URLParam(req, "metricType")
        metricName := chi.URLParam(req, "metricName")

        value, err := storage.GetMetric(req.Context(), metricType, metricName)
        if err != nil </span><span class="cov8" title="1">{
                logger.ServerLog.Error("get metric error", zap.String("address", req.URL.String()), zap.String("error", error.Error(err)))
                http.Error(res, err.Error(), http.StatusNotFound)
                return
        }</span>
        // устанавливаю заголовок таким образом вместо WriteHeader(http.StatusOK), потому что
        // далее в методе Write в middleware необходимо установить заголовок Hash со значением хэша,
        // а после WriteHeader заголовки уже не устанавливаются
        <span class="cov8" title="1">res.Header().Set("Status-Code", "200")

        n, err := res.Write([]byte(value))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Write error in GetMetric handler: %v\n", err)
                return
        }</span>
        <span class="cov8" title="1">if n &lt; len(value) </span><span class="cov0" title="0">{
                log.Printf("Not all bytes were written in GetMetric handler. Written: %d, Total: %d", n, len(value))
        }</span>
}

// UpdateMetricsBatch - обновляет метрики через json батч, который является слайсом метрик.
func UpdateMetricsBatch(res http.ResponseWriter, req *http.Request, storage repositories.MetricsWriter) <span class="cov8" title="1">{
        // Проверка на nil для storage
        if storage == nil </span><span class="cov8" title="1">{
                http.Error(res, "Storage not initialized", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">res.Header().Set("Content-Type", "application/json")

        metrics := make([]repositories.Metric, 0)

        if err := json.NewDecoder(req.Body).Decode(&amp;metrics); err != nil </span><span class="cov8" title="1">{
                logger.ServerLog.Error("Decode message error", zap.String("address", req.URL.String()))
                http.Error(res, "Decode message error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">err := storage.AddMetricsFromSlice(req.Context(), metrics)
        if err != nil </span><span class="cov8" title="1">{
                logger.ServerLog.Error("add metric into server error", zap.String("address", req.URL.String()), zap.String("error", error.Error(err)))
                http.Error(res, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">logger.ServerLog.Debug("Successful decode metrcic from json", zap.String("address: ", req.URL.String()))

        // устанавливаю заголовок таким образом вместо WriteHeader(http.StatusOK), потому что
        // далее в методе Write в middleware необходимо установить заголовок Hash со значением хэша,
        // а после WriteHeader заголовки уже не устанавливаются
        res.Header().Set("Status-Code", "200")

        enc := json.NewEncoder(res)
        if err := enc.Encode(metrics); err != nil </span><span class="cov0" title="0">{
                logger.ServerLog.Error("error encoding response", zap.String("error", error.Error(err)))
                return
        }</span>

        <span class="cov0" title="0">logger.ServerLog.Debug("successful write encode data, server answer is", zap.String("Content-Encoding", res.Header().Get("Content-Encoding")),
                zap.String("Status-Code", res.Header().Get("Status-Code")),
                zap.String("Content-Type", res.Header().Get("Content-Type")),
                zap.String("HashSHA256", res.Header().Get("HashSHA256")))</span>
}

// UpdateMetricsJSON - для обновления метрик через json.
// Благодаря использованию роутера chi в этот хэндлер будут попадать только запросы POST.
func UpdateMetricsJSON(res http.ResponseWriter, req *http.Request, storage repositories.MetricsWriter) <span class="cov8" title="1">{
        // Проверка на nil для storage
        if storage == nil </span><span class="cov8" title="1">{
                http.Error(res, "Storage not initialized", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">res.Header().Set("Content-Type", "application/json")

        var metrics = repositories.Metric{}

        if err := json.NewDecoder(req.Body).Decode(&amp;metrics); err != nil </span><span class="cov8" title="1">{
                logger.ServerLog.Error("Decode message error", zap.String("address", req.URL.String()))
                http.Error(res, "Decode message error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">switch metrics.MType </span>{
        case "gauge":<span class="cov8" title="1">
                if metrics.Value == nil </span><span class="cov8" title="1">{
                        logger.ServerLog.Error("Decode message error, value in gauge metric is nil", zap.String("address", req.URL.String()))
                        res.WriteHeader(http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">err := storage.AddGauge(req.Context(), metrics.ID, *metrics.Value)
                if err != nil </span><span class="cov0" title="0">{
                        logger.ServerLog.Error("add gauge error", zap.String("address", req.URL.String()), zap.String("error", error.Error(err)))
                        http.Error(res, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
        case "counter":<span class="cov8" title="1">
                if metrics.Delta == nil </span><span class="cov8" title="1">{
                        logger.ServerLog.Error("Decode message error, delta in counter metric is nil", zap.String("address", req.URL.String()))
                        res.WriteHeader(http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">err := storage.AddCounter(req.Context(), metrics.ID, *metrics.Delta)
                if err != nil </span><span class="cov8" title="1">{
                        logger.ServerLog.Error("add counter error", zap.String("address", req.URL.String()), zap.String("error", error.Error(err)))
                        http.Error(res, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
        default:<span class="cov8" title="1">
                logger.ServerLog.Error("Invalid type of metric", zap.String("type", metrics.MType)) //---------------------------------------------
                res.WriteHeader(http.StatusBadRequest)
                return</span>
        }
        <span class="cov8" title="1">logger.ServerLog.Debug("Successful decode metrcic from json", zap.String("address: ", req.URL.String()))

        bodyDebug, _ := io.ReadAll(req.Body)
        logger.ServerLog.Debug("message before compress", zap.String("bytes: ", string(bodyDebug)))

        // устанавливаю заголовок таким образом вместо WriteHeader(http.StatusOK), потому что
        // далее в методе Write в middleware необходимо установить заголовок Hash со значением хэша,
        // а после WriteHeader заголовки уже не устанавливаются
        res.Header().Set("Status-Code", "200")

        enc := json.NewEncoder(res)
        if err := enc.Encode(metrics); err != nil </span><span class="cov0" title="0">{
                logger.ServerLog.Error("error encoding response", zap.String("error", error.Error(err)))
                return
        }</span>

        <span class="cov8" title="1">logger.ServerLog.Debug("successful write encode data to answer message")

        logger.ServerLog.Debug("server answer is", zap.String("Content-Encoding", res.Header().Get("Content-Encoding")),
                zap.String("Status-Code", res.Header().Get("Status-Code")),
                zap.String("HashSHA256", res.Header().Get("HashSHA256")),
                zap.String("Content-Type", res.Header().Get("Content-Type")))</span>
}

// UpdateMetrics - обновляет метрику на сервере. Параметры метрики извлекаются из http запроса.
func UpdateMetrics(res http.ResponseWriter, req *http.Request, storage repositories.MetricsWriter) <span class="cov8" title="1">{

        // Проверка на nil для storage
        if storage == nil </span><span class="cov8" title="1">{
                http.Error(res, "Storage not initialized", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">res.Header().Set("Content-Type", "text/plain")

        metricType := chi.URLParam(req, "metricType")
        metricName := chi.URLParam(req, "metricName")
        metricValue := chi.URLParam(req, "metricValue")

        if metricName == "" </span><span class="cov0" title="0">{
                res.WriteHeader(http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">switch metricType </span>{
        case "gauge":<span class="cov8" title="1">
                value, err := strconv.ParseFloat(metricValue, 64)
                if err != nil </span><span class="cov8" title="1">{
                        res.WriteHeader(http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">err = storage.AddGauge(req.Context(), metricName, value)
                if err != nil </span><span class="cov0" title="0">{
                        logger.ServerLog.Error("add gauge error", zap.String("address", req.URL.String()), zap.String("error", error.Error(err)))
                        http.Error(res, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
        case "counter":<span class="cov8" title="1">
                value, err := strconv.ParseInt(metricValue, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        res.WriteHeader(http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">err = storage.AddCounter(req.Context(), metricName, value)
                if err != nil </span><span class="cov0" title="0">{
                        logger.ServerLog.Error("add counter error", zap.String("address", req.URL.String()), zap.String("error", error.Error(err)))
                        http.Error(res, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
        default:<span class="cov8" title="1">
                res.WriteHeader(http.StatusBadRequest)
                return</span>
        }

        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}

// GetGlobalHandler - обертка над GetGlobal для возможности установить хранилище метрик.
func GetGlobalHandler(stor repositories.MetricsReader) http.HandlerFunc <span class="cov0" title="0">{
        fn := func(res http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                GetGlobal(res, req, stor)
        }</span>
        <span class="cov0" title="0">return fn</span>
}

// PingDatabaseHandler - обертка над PingDatabase для возможности установить базу данных.
func PingDatabaseHandler(db *sql.DB) http.HandlerFunc <span class="cov8" title="1">{
        fn := func(res http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                PingDatabase(res, req, db)
        }</span>
        <span class="cov8" title="1">return fn</span>
}

// UpdateMetricsBatchHandler - обертка над UpdateMetricsBatch для возможности установить хранилище метрик.
func UpdateMetricsBatchHandler(stor repositories.MetricsWriter) http.HandlerFunc <span class="cov8" title="1">{
        fn := func(res http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                UpdateMetricsBatch(res, req, stor)
        }</span>
        <span class="cov8" title="1">return fn</span>
}

// UpdateMetricsJSONHandler - обертка над UpdateMetricsJSON для возможности установить хранилище метрик.
func UpdateMetricsJSONHandler(stor repositories.MetricsWriter) http.HandlerFunc <span class="cov8" title="1">{
        fn := func(res http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                UpdateMetricsJSON(res, req, stor)
        }</span>
        <span class="cov8" title="1">return fn</span>
}

// UpdateMetricsHandler - обертка над UpdateMetrics для возможности установить хранилище метрик.
func UpdateMetricsHandler(stor repositories.MetricsWriter) http.HandlerFunc <span class="cov8" title="1">{
        fn := func(res http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                UpdateMetrics(res, req, stor)
        }</span>
        <span class="cov8" title="1">return fn</span>
}

// GetMetricJSONHandler - обертка над GetMetricJSON для возможности установить хранилище метрик.
func GetMetricJSONHandler(stor repositories.MetricsReader) http.HandlerFunc <span class="cov0" title="0">{
        fn := func(res http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                GetMetricJSON(res, req, stor)
        }</span>
        <span class="cov0" title="0">return fn</span>
}

// GetMetricHandler - обертка над GetMetric для возможности установить хранилище метрик.
func GetMetricHandler(stor repositories.MetricsReader) http.HandlerFunc <span class="cov0" title="0">{
        fn := func(res http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                GetMetric(res, req, stor)
        }</span>
        <span class="cov0" title="0">return fn</span>
}

// OtherRequestHandler - обертка над OtherRequest для возможности установить хранилище метрик.
func OtherRequestHandler() http.HandlerFunc <span class="cov8" title="1">{
        fn := func(res http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                OtherRequest(res, req)
        }</span>
        <span class="cov8" title="1">return fn</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package hasher

import (
        "bytes"
        "fmt"
        "io"
        "net/http"

        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
)

var key string

// SetKey - устанавливает секретный ключ для подписи данных.
func SetKey(k string) <span class="cov8" title="1">{
        key = k
}</span>

// GetKey - возвращает секретный ключ для подписи данных.
func GetKey() string <span class="cov8" title="1">{
        return key
}</span>

// HashMiddleware - middleware для проверки подписи и подписи данных, если установлен ключ.
func HashMiddleware(handler http.Handler) http.HandlerFunc <span class="cov8" title="1">{
        logFn := func(res http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                if k := GetKey(); k == "" </span><span class="cov8" title="1">{
                        handler.ServeHTTP(res, req)
                        return
                }</span>

                // О необходимости такого поведения понял из тестов
                <span class="cov8" title="1">noneHash := req.Header.Get("Hash")
                if noneHash == "none" </span><span class="cov8" title="1">{
                        handler.ServeHTTP(res, req)
                        return
                }</span>
                <span class="cov8" title="1">reqHash := req.Header.Get("HashSHA256")
                if reqHash == "" </span><span class="cov8" title="1">{
                        handler.ServeHTTP(res, req)
                        return
                }</span>

                // Проверяю подпись----------------------------------------
                <span class="cov8" title="1">body, err := io.ReadAll(req.Body)
                if err != nil </span><span class="cov8" title="1">{
                        logger.ServerLog.Error("read body into string error: ", zap.String("address", req.URL.String()), zap.String("error: ", error.Error(err)))
                        http.Error(res, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">logger.ServerLog.Debug("geting body from agent ", zap.String("body: ", fmt.Sprintf("%x", body)))

                // Восстанавливаем тело запроса, чтобы другие хендлеры могли его использовать
                req.Body = io.NopCloser(bytes.NewReader(body))

                // проверка подписи в случае непустого тела запроса
                if len(body) != 0 </span><span class="cov8" title="1">{
                        ok, err := repositories.CheckHash(body, reqHash, GetKey())
                        if err != nil </span><span class="cov8" title="1">{
                                logger.ServerLog.Error("checking hash error", zap.String("address", req.URL.String()), zap.String("error: ", error.Error(err)))

                                res.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                                logger.ServerLog.Error("hashs is not equal ", zap.String("address", req.URL.String()))
                                res.WriteHeader(http.StatusBadRequest)
                                return
                        }</span>
                }

                // Подписываю ответ сервера в случае, если задан ключ---------------------------------------------
                // Устанавливаю мидлварь для получения тела ответа сервера
                <span class="cov8" title="1">var writer = repositories.NewHashWriter(res, GetKey())
                handler.ServeHTTP(writer, req)</span>
        }
        <span class="cov8" title="1">return logFn</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package ipfilter

import (
        "net/http"

        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/tools/ipchecker"
)

// trustedSubnet - переменная, которая хранит строковое представление бесклассовой адресации (CIDR).
var trustedSubnet string

// SetTrustedSubnet - функция для установки строкового представления бесклассовой адресации (CIDR).
func SetTrustedSubnet(t string) <span class="cov8" title="1">{
        trustedSubnet = t
}</span>

// getTrustedSubnet - функция для получения строкового представления бесклассовой адресации (CIDR).
func GetTrustedSubnet() string <span class="cov8" title="1">{
        return trustedSubnet
}</span>

// Middleware - мидлварь для проверки вхождения ip адреса в доверенную сеть. Ip адрес извлекается из заголовка X-Real-IP.
// Проверка осуществляется только в случае, если установлена переменная trustedSubnet.
func Middleware(h http.HandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                subnet := GetTrustedSubnet()

                // проверяю вхождение Ip адреса в доверенную сеть только в том случае, если установлена переменная trustedSubnet
                if subnet != "" </span><span class="cov8" title="1">{
                        realIP := r.Header.Get("X-Real-IP")

                        logger.ServerLog.Debug("real ip of agent host is", zap.String("nrealip", realIP))

                        if realIP == "" </span><span class="cov8" title="1">{
                                w.WriteHeader(http.StatusForbidden)
                                return
                        }</span>
                        // проверка вхождения ip в доверенную сеть
                        <span class="cov8" title="1">intrusted, err := ipchecker.InTrustedSubNet(subnet, realIP)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.ServerLog.Error("in trusted subNet check error", zap.String("error", error.Error(err)))
                                http.Error(w, err.Error(), http.StatusInternalServerError)
                        }</span>
                        <span class="cov8" title="1">if !intrusted </span><span class="cov8" title="1">{
                                logger.ServerLog.Info("ip of agent not in trusted sub net")
                                w.WriteHeader(http.StatusForbidden)
                                return
                        }</span>
                }

                // передаём управление хендлеру
                <span class="cov8" title="1">h.ServeHTTP(w, r)</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package logger

import (
        "net/http"
        "time"

        "go.uber.org/zap"
)

type (
        // берём структуру для хранения сведений об ответе
        responseData struct {
                status int
                size   int
        }

        // добавляем реализацию http.ResponseWriter
        loggingResponseWriter struct {
                http.ResponseWriter // встраиваем оригинальный http.ResponseWriter
                responseData        *responseData
        }
)

// loggingResponseWriter_Write - обертка над оригинальным http.ResponseWriter_Write
func (r *loggingResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        // записываем ответ, используя оригинальный http.ResponseWriter
        size, err := r.ResponseWriter.Write(b)
        r.responseData.size += size // захватываем размер
        return size, err
}</span>

// loggingResponseWriter_WriteHeader - обертка над оригинальным http.ResponseWriter_WriteHeader
func (r *loggingResponseWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        // записываем код статуса, используя оригинальный http.ResponseWriter
        r.ResponseWriter.WriteHeader(statusCode)
        r.responseData.status = statusCode // захватываем код статуса
}</span>

// Log будет доступен всему коду как синглтон.
// Никакой код, кроме функции InitLogger, не должен модифицировать эту переменную.
// По умолчанию установлен no-op-логер, который не выводит никаких сообщений.
var ServerLog *zap.Logger = zap.NewNop()

// Log для GRPC сервера, который так-же доступен как синглтон
var ServerGRPCLog *zap.Logger = zap.NewNop()

// Initialize инициализирует синглтон логера с необходимым уровнем логирования.
func Initialize(level string) error <span class="cov8" title="1">{
        // преобразуем текстовый уровень логирования в zap.AtomicLevel
        lvl, err := zap.ParseAtomicLevel(level)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // создаём новую конфигурацию логера
        <span class="cov8" title="1">cfg := zap.NewProductionConfig()
        // устанавливаем уровень
        cfg.Level = lvl
        // создаём логер на основе конфигурации
        zl, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // устанавливаем синглтон
        <span class="cov8" title="1">ServerLog = zl.With(zap.String("role", "server"))

        // создаю лог для grpc на основе конфигурации
        grpcZl, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // устанавливаем синглтон
        <span class="cov8" title="1">ServerGRPCLog = grpcZl.With(zap.String("role", "grpcServer"))

        return nil</span>
}

// RequestLogger — middleware-логер для входящих HTTP-запросов.
func RequestLogger(h http.Handler) http.HandlerFunc <span class="cov8" title="1">{
        logFn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()

                responseData := &amp;responseData{
                        status: 0,
                        size:   0,
                }
                lw := loggingResponseWriter{
                        ResponseWriter: w, // встраиваем оригинальный http.ResponseWriter
                        responseData:   responseData,
                }
                h.ServeHTTP(&amp;lw, r) // внедряем реализацию http.ResponseWriter

                duration := time.Since(start)

                sugar := ServerLog.Sugar()
                sugar.Infoln(
                        "uri", r.RequestURI,
                        "method", r.Method,
                        "status", responseData.status, // получаем перехваченный код статуса ответа
                        "duration", duration,
                        "size", responseData.size, // получаем перехваченный размер ответа,
                        "status_code", w.Header().Get("Status-Code"), // получаю заголовок со статусом
                )
        }</span>
        <span class="cov8" title="1">return logFn</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package pg

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
)

// Store реализует интерфейс store.Store и позволяет взаимодействовать с СУБД PostgreSQL.
// Так же Store реализует интерфейс repositories.ServerRepo, для возможности использования структуры в качестве хранилища метрик.
type Store struct {
        // Поле conn содержит объект соединения с СУБД
        conn *sql.DB
}

// NewStore возвращает новый экземпляр PostgreSQL-хранилища
func NewStore(conn *sql.DB) *Store <span class="cov8" title="1">{
        return &amp;Store{conn: conn}
}</span>

// Bootstrap - подготавливает БД к работе, создавая необходимые таблицы и индексы.
func (s Store) Bootstrap(ctx context.Context) error <span class="cov8" title="1">{
        // запускаем транзакцию
        tx, err := s.conn.BeginTx(ctx, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // в случае неуспешного коммита все изменения транзакции будут отменены
        <span class="cov8" title="1">defer tx.Rollback()

        // создаём таблицу с метриками и необходимые индексы, если таблица ещё не существует
        _, errExec := tx.ExecContext(ctx, `
        CREATE TABLE IF NOT EXISTS metrics (
                        id varchar(128) PRIMARY KEY,
                        mtype varchar(128),
                        delta bigint DEFAULT NULL,
                        value double precision DEFAULT NULL
        )
    `)
        if errExec != nil </span><span class="cov0" title="0">{
                return errExec
        }</span>
        <span class="cov8" title="1">_, errExec = tx.ExecContext(ctx, `CREATE UNIQUE INDEX IF NOT EXISTS id ON metrics (id)`)
        if errExec != nil </span><span class="cov0" title="0">{
                return errExec
        }</span>

        // коммитим транзакцию
        <span class="cov8" title="1">return tx.Commit()</span>
}

// Disable - очищает БД, удаляя записи из таблиц.
// Метод необходим для тестирования, чтобы в процессе удалять тестовые записи.
func (s Store) Disable(ctx context.Context) (err error) <span class="cov8" title="1">{
        logger.ServerLog.Debug("truncate all data in all tables")

        // запускаем транзакцию
        tx, err := s.conn.BeginTx(ctx, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // в случае неуспешного коммита все изменения транзакции будут отменены
        <span class="cov8" title="1">defer tx.Rollback()

        // удаляю все записи в таблице auth
        _, err = tx.ExecContext(ctx, `
                        TRUNCATE TABLE metrics 
        `)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // коммитим транзакцию
        <span class="cov8" title="1">return tx.Commit()</span>
}

// GetMetric -возвращает значение метрики в строчном представлении по имени и типу метрики.
func (s Store) GetMetric(ctx context.Context, metricType string, metricName string) (string, error) <span class="cov8" title="1">{
        query := `
                SELECT id,
                           mtype,
                           delta,
                           value
                FROM metrics
                WHERE id = $1
        `
        stmt, err := s.conn.PrepareContext(ctx, query)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("prepare context error in DB, %w", err)
        }</span>
        <span class="cov8" title="1">defer stmt.Close()
        row := stmt.QueryRowContext(ctx, metricName)

        var metric repositories.Metric
        err = row.Scan(&amp;metric.ID, &amp;metric.MType, &amp;metric.Delta, &amp;metric.Value)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if metric.MType != metricType </span><span class="cov8" title="1">{
                return "", fmt.Errorf("metric type is different, metric type in database is: %s, metric type in request is: %s", metric.MType, metricType)
        }</span>
        <span class="cov8" title="1">if metric.MType == "gauge" </span><span class="cov8" title="1">{
                if metric.Value == nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("value of gauge metric is nil")
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%g", *metric.Value), nil</span>
        } else<span class="cov8" title="1"> if metric.MType == "counter" </span><span class="cov8" title="1">{
                if metric.Delta == nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("value of counter metric is nil")
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d", *metric.Delta), nil</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("whrong type of metric")</span>
}

// AddGauge - реализует метод AddGauge интерфейса repositories.ServerRepo.
func (s Store) AddGauge(ctx context.Context, nameMetric string, value float64) (err error) <span class="cov8" title="1">{
        queryUpsert := `
                                INSERT INTO metrics (id, mtype, value)
                                VALUES ($1, $2, $3)
                                ON CONFLICT (id) 
                                DO UPDATE SET value = EXCLUDED.value;
                                `
        stmt, err := s.conn.PrepareContext(ctx, queryUpsert)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("prepare context error in DB, %w", err)
        }</span>
        <span class="cov8" title="1">defer stmt.Close()
        _, err = stmt.ExecContext(ctx, nameMetric, "gauge", value)
        return err</span>
}

// AddCounter - реализует метод AddCounter интерфейса repositories.ServerRepo.
func (s Store) AddCounter(ctx context.Context, nameMetric string, value int64) (err error) <span class="cov8" title="1">{
        queryUpsert := `
                                INSERT INTO metrics (id, mtype, delta)
                                VALUES ($1, $2, $3)
                                ON CONFLICT (id) 
                                DO UPDATE SET delta = metrics.delta + EXCLUDED.delta;
                                `
        stmt, err := s.conn.PrepareContext(ctx, queryUpsert)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("prepare context error in DB, %w", err)
        }</span>
        <span class="cov8" title="1">defer stmt.Close()
        _, err = stmt.ExecContext(ctx, nameMetric, "counter", value)
        return err</span>
}

// GetAllMetrics - реализует метод GetAllMetrics интерфейса repositories.ServerRepo.
func (s Store) GetAllMetrics(ctx context.Context) (string, error) <span class="cov8" title="1">{
        metrics, err := s.GetAllMetricsSlice(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">var result string
        for _, metric := range metrics </span><span class="cov8" title="1">{
                if metric.MType == "gauge" </span><span class="cov8" title="1">{
                        result += fmt.Sprintf("type: %s, name: %s, value: %g\n", metric.MType, metric.ID, *metric.Value)
                }</span> else<span class="cov8" title="1"> {
                        result += fmt.Sprintf("type: %s, name: %s, value: %d\n", metric.MType, metric.ID, *metric.Delta)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// AddMetricsFromSlice - реализует метод AddMetricsFromSlice интерфейса repositories.ServerRepo.
func (s Store) AddMetricsFromSlice(ctx context.Context, metrics []repositories.Metric) error <span class="cov8" title="1">{
        // запускаем транзакцию
        tx, err := s.conn.BeginTx(ctx, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // в случае неуспешного коммита все изменения транзакции будут отменены
        <span class="cov8" title="1">defer tx.Rollback()

        for _, metric := range metrics </span><span class="cov8" title="1">{

                if metric.MType == "gauge" </span><span class="cov8" title="1">{
                        queryUpsert := `
                                INSERT INTO metrics (id, mtype, value)
                                VALUES ($1, $2, $3)
                                ON CONFLICT (id) 
                                DO UPDATE SET value = EXCLUDED.value;
                                `
                        stmt, err := tx.PrepareContext(ctx, queryUpsert)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("prepare context error in DB, %w", err)
                        }</span>
                        <span class="cov8" title="1">defer stmt.Close()
                        _, err = stmt.ExecContext(ctx, metric.ID, "gauge", metric.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        queryUpsert := `
                                        INSERT INTO metrics (id, mtype, delta)
                                        VALUES ($1, $2, $3)
                                        ON CONFLICT (id) 
                                        DO UPDATE SET delta = metrics.delta + EXCLUDED.delta;
                                        `
                        stmt, err := tx.PrepareContext(ctx, queryUpsert)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("prepare context error in DB, %w", err)
                        }</span>
                        <span class="cov8" title="1">defer stmt.Close()
                        _, err = stmt.ExecContext(ctx, metric.ID, "counter", metric.Delta)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }
        // коммитим транзакцию
        <span class="cov8" title="1">return tx.Commit()</span>
}

// GetAllMetricsSlice - реализует метод GetAllMetricsSlice интерфейса repositories.ServerRepo.
func (s Store) GetAllMetricsSlice(ctx context.Context) ([]repositories.Metric, error) <span class="cov8" title="1">{
        metrics := make([]repositories.Metric, 0)

        stmt, err := s.conn.PrepareContext(ctx, "SELECT id, mtype, delta, value FROM metrics")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("prepare context error in DB, %w", err)
        }</span>
        <span class="cov8" title="1">defer stmt.Close()
        rows, err := stmt.QueryContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                var metric repositories.Metric
                err = rows.Scan(&amp;metric.ID, &amp;metric.MType, &amp;metric.Delta, &amp;metric.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">metrics = append(metrics, metric)</span>
        }
        // проверяем на ошибки
        <span class="cov8" title="1">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return metrics, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Пакет для сохранения метрик в файл
package saver

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "time"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
)

// Global variable -------------------------------------------------
var (
        storeInterval   time.Duration
        fileStoragePath string
        restore         bool
)

// SetStoreInterval - устанавливает переменну storeInterval.
func SetStoreInterval(interval time.Duration) <span class="cov8" title="1">{
        storeInterval = interval
}</span>

// GetStoreInterval - возвращает переменну storeInterval.
func GetStoreInterval() time.Duration <span class="cov8" title="1">{
        return storeInterval
}</span>

// SetFilestoragePath - устанавливает переменну fileStoragePath.
func SetFilestoragePath(path string) <span class="cov8" title="1">{
        fileStoragePath = path
}</span>

// GetFilestoragePath - возвращает переменну fileStoragePath.
func GetFilestoragePath() string <span class="cov8" title="1">{
        return fileStoragePath
}</span>

// SetRestore - устанавливает переменну restore.
func SetRestore(r bool) <span class="cov8" title="1">{
        restore = r
}</span>

// GetRestore - возвращает переменну restore.
func GetRestore() bool <span class="cov8" title="1">{
        return restore
}</span>

// end Global variable -------------------------------------------------

// FileWriter - интерфейс записи метрик.
type FileWriter interface {
        WriteMetrics(repositories.MetricsReader) error // Метод записи.
}

// FileReader - интерфейс чтения метрик.
type FileReader interface {
        ReadMetrics() ([]repositories.Metric, error) // Метод чтения.
}

// SaverWriter --------------------------------------------------------------------------------------------------

// Writer - реализация интерфейса FileWriter
type Writer struct {
        file     *os.File
        writer   *bufio.Writer
        filename string
}

// NewWriter - фабричный метод для создания структуры Writer.
func NewWriter(filename string) (*Writer, error) <span class="cov8" title="1">{
        // При создании файла удаляю предыдущее содержимое
        file, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Writer{
                file:     file,
                writer:   bufio.NewWriter(file),
                filename: filename,
        }, nil</span>
}

// Close - метод закрытия.
func (storage *Writer) Close() error <span class="cov8" title="1">{
        if err := storage.writer.Flush(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return storage.file.Close()</span>
}

// WriteMetrics - сохраняю метрики из сервера в файл, причем предыдущее содержимое файла удаляю
func (storage *Writer) WriteMetrics(metrics repositories.MetricsReader) error <span class="cov8" title="1">{
        metricsSlice, err := metrics.GetAllMetricsSlice(context.Background())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if len(metricsSlice) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var metricsJSON bytes.Buffer
        enc := json.NewEncoder(&amp;metricsJSON)
        if err := enc.Encode(metricsSlice); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Закрываем текущий writer и файл
        <span class="cov8" title="1">if err := storage.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Переоткрываем файл с флагами O_WRONLY и O_TRUNC для очистки
        <span class="cov8" title="1">file, err := os.OpenFile(storage.file.Name(), os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">storage.file = file
        storage.writer = bufio.NewWriter(file)

        n, err := storage.writer.Write(metricsJSON.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if n != len(metricsJSON.Bytes()) </span><span class="cov0" title="0">{
                return fmt.Errorf("write metrics to file error: want write %d bytes, actual write %d bytes", len(metricsJSON.Bytes()), n)
        }</span>
        <span class="cov8" title="1">if err := storage.writer.Flush(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">logger.ServerLog.Info("write metrics to file")
        return nil</span>
}

// Reader --------------------------------------------------------------------------------------------------

// Reader - реализация интерфейса FileReader.
type Reader struct {
        file   *os.File
        reader *bufio.Reader
}

// NewReader - фабричный метод для создания структуры Reader.
func NewReader(filename string) (*Reader, error) <span class="cov8" title="1">{
        file, err := os.OpenFile(filename, os.O_RDONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Reader{
                file: file,
                // создаём новый Reader
                reader: bufio.NewReader(file),
        }, nil</span>
}

// ReadMetrics - метод для чтения метрик из файла и записи их в слайс.
func (saver *Reader) ReadMetrics() ([]repositories.Metric, error) <span class="cov8" title="1">{
        var bufRead bytes.Buffer

        _, err := bufRead.ReadFrom(saver.reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">bytesForRead := bufRead.Bytes()
        if len(bytesForRead) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // преобразуем данные из JSON-представления в структуру
        <span class="cov8" title="1">var metrics = make([]repositories.Metric, 0)

        dec := json.NewDecoder(&amp;bufRead)
        er := dec.Decode(&amp;metrics)
        if er != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return metrics, nil</span>
}

// AddMetricsFromFile - функция для загрузки метрик из файла в сервер.
func AddMetricsFromFile(stor repositories.MetricsWriter, reader FileReader) error <span class="cov8" title="1">{
        if GetRestore() </span><span class="cov8" title="1">{
                metrics, err := reader.ReadMetrics()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := stor.AddMetricsFromSlice(context.Background(), metrics); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// реализация интерфейса хранилища метрик
package storage

import (
        "context"
        "fmt"
        "sync"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/repositories"
)

// Хранилище метрик ------------------------------------------------------------------------------------

// MemStorage - реализует интерфейс repositories.ServerRepo, для возможности использования структуры в качестве хранилища метрик.
type MemStorage struct {
        sync.Mutex
        gauges   map[string]float64
        counters map[string]int64
}

// NewDefaultMemStorage - фабричная функция для создания структуры MemStorage с параметрами по умолчанию.
func NewDefaultMemStorage() *MemStorage <span class="cov8" title="1">{
        return &amp;MemStorage{
                gauges:   make(map[string]float64),
                counters: make(map[string]int64),
        }
}</span>

// NewDefaultMemStorage - фабричная функция для создания структуры MemStorage с принятыми параметрами.
func NewMemStorage(gaugesArg map[string]float64, countersArg map[string]int64) *MemStorage <span class="cov8" title="1">{
        if gaugesArg == nil </span><span class="cov8" title="1">{
                gaugesArg = make(map[string]float64)
        }</span>
        <span class="cov8" title="1">if countersArg == nil </span><span class="cov8" title="1">{
                countersArg = make(map[string]int64)
        }</span>
        <span class="cov8" title="1">return &amp;MemStorage{
                gauges:   gaugesArg,
                counters: countersArg,
        }</span>
}

// AddGauge - реализует метод AddGauge интерфейса repositories.ServerRepo.
func (storage *MemStorage) AddGauge(ctx context.Context, name string, guage float64) error <span class="cov8" title="1">{
        storage.Mutex.Lock()
        defer storage.Mutex.Unlock()
        storage.gauges[name] = guage
        return nil
}</span>

// AddCounter - реализует метод AddCounter интерфейса repositories.ServerRepo.
func (storage *MemStorage) AddCounter(ctx context.Context, name string, counter int64) error <span class="cov8" title="1">{
        storage.Mutex.Lock()
        defer storage.Mutex.Unlock()
        storage.counters[name] += counter
        return nil
}</span>

// GetMetric - реализует метод GetMetric интерфейса repositories.ServerRepo.
func (storage *MemStorage) GetMetric(ctx context.Context, metricType, name string) (string, error) <span class="cov8" title="1">{
        storage.Mutex.Lock()
        defer storage.Mutex.Unlock()

        if metricType == "gauge" </span><span class="cov8" title="1">{
                val, ok := storage.gauges[name]
                if !ok </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("metric %s of type gauge not found", name)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%g", val), nil</span>
        }

        <span class="cov8" title="1">if metricType == "counter" </span><span class="cov8" title="1">{
                val, ok := storage.counters[name]
                if !ok </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("metric %s of type counter not found", name)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d", val), nil</span>
        }
        <span class="cov8" title="1">return "", fmt.Errorf("whrong type of metric")</span>
}

// GetAllMetrics - реализует метод GetAllMetrics интерфейса repositories.ServerRepo.
func (storage *MemStorage) GetAllMetrics(ctx context.Context) (string, error) <span class="cov8" title="1">{
        storage.Mutex.Lock()
        defer storage.Mutex.Unlock()

        var result string
        for name, val := range storage.gauges </span><span class="cov8" title="1">{
                result += fmt.Sprintf("%s: %g\n", name, val)
        }</span>

        <span class="cov8" title="1">for name, val := range storage.counters </span><span class="cov8" title="1">{
                result += fmt.Sprintf("%s: %d\n", name, val)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// GetAllMetricsSlice - реализует метод GetAllMetricsSlice интерфейса repositories.ServerRepo.
func (storage *MemStorage) GetAllMetricsSlice(ctx context.Context) ([]repositories.Metric, error) <span class="cov8" title="1">{
        storage.Mutex.Lock()
        defer storage.Mutex.Unlock()

        result := make([]repositories.Metric, 0)
        for name, value := range storage.gauges </span><span class="cov8" title="1">{
                metric := repositories.Metric{
                        ID:    name,
                        MType: "gauge",
                        Value: &amp;value,
                }
                result = append(result, metric)
        }</span>
        <span class="cov8" title="1">for name, delta := range storage.counters </span><span class="cov8" title="1">{
                metric := repositories.Metric{
                        ID:    name,
                        MType: "counter",
                        Delta: &amp;delta,
                }
                result = append(result, metric)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// AddMetricsFromSlice - реализует метод AddMetricsFromSlice интерфейса repositories.ServerRepo.
func (storage *MemStorage) AddMetricsFromSlice(ctx context.Context, metrics []repositories.Metric) error <span class="cov8" title="1">{
        if metrics == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, metric := range metrics </span><span class="cov8" title="1">{
                if metric.MType == "gauge" </span><span class="cov8" title="1">{
                        if metric.Value == nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid metric, value of gauge metric is nil")
                        }</span>
                        <span class="cov8" title="1">err := storage.AddGauge(ctx, metric.ID, *metric.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add gauge error: %f", err)
                        }</span>
                } else<span class="cov8" title="1"> if metric.MType == "counter" </span><span class="cov8" title="1">{
                        if metric.Delta == nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid metric, delta of counter metric is nil")
                        }</span>
                        <span class="cov8" title="1">err := storage.AddCounter(ctx, metric.ID, *metric.Delta)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add counter error: %f", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid metric, undefined type of metric: %s", metric.MType)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// MemStorage_Bootstrap - реализует метод Bootstrap интерфейса repositories.ServerRepo.
func (storage *MemStorage) Bootstrap(ctx context.Context) error <span class="cov8" title="1">{
        return nil
}</span>

// Clean - очищает хранилище от данных.
func (storage *MemStorage) Clean(ctx context.Context) <span class="cov8" title="1">{
        storage.counters = map[string]int64{}
        storage.gauges = map[string]float64{}
}</span>

// Хранилище метрик -----------------------------------------------------------------------------------------
</pre>
		
		<pre class="file" id="file38" style="display: none">package encryption

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "os"
)

// Cryptographer - структура хранящая приватный и публичный ключи шифрования с методами для шифровки и расшифровки данных.
type Cryptographer struct {
        publicKeyPath  string
        privateKeyPath string
}

// Initialize инициализирует синглтон структуры шифрования с публичным и приватным ключом.
func Initialize(publicKeyPath, privateKeyPath string) *Cryptographer <span class="cov8" title="1">{
        return &amp;Cryptographer{
                publicKeyPath:  publicKeyPath,
                privateKeyPath: privateKeyPath,
        }
}</span>

// Encrypt шифрует данные, используя публичный ключ.
func (c *Cryptographer) Encrypt(data []byte) ([]byte, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("empty data for encrypt is error")
        }</span>

        // Парсинг публичного ключа
        <span class="cov8" title="1">rsaPubKey, err := ParsePublicKey(c.publicKeyPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("read public key error: %w", err)
        }</span>

        // Шифрование данных с использованием RSA с заполнением OAEP (Optimal Asymmetric Encryption Padding)
        <span class="cov8" title="1">encryptedData, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, rsaPubKey, data, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return encryptedData, nil</span>
}

// Decrypt расшифровывает данные, используя приватный ключ.
func (c *Cryptographer) Decrypt(data []byte) ([]byte, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("empty data for decypher is error")
        }</span>

        // Парсинг приватного ключа
        <span class="cov8" title="1">privKey, err := ParsePrivateKey(c.privateKeyPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Расшифровка данных с использованием RSA с заполнением OAEP (Optimal Asymmetric Encryption Padding)
        <span class="cov8" title="1">decryptedData, err := rsa.DecryptOAEP(sha256.New(), rand.Reader, privKey, data, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return decryptedData, nil</span>
}

// PublicKeyIsSet - функция для определения того, что задан ли публичный ключ шифрования
func (c *Cryptographer) PublicKeyIsSet() bool <span class="cov8" title="1">{
        if c.publicKeyPath != "" </span><span class="cov8" title="1">{
                return true
        }</span> else<span class="cov8" title="1"> {
                return false
        }</span>
}

// PrivateKeyIsSet - функция для определения того, что задан ли приватный ключ шифрования
func (c *Cryptographer) PrivateKeyIsSet() bool <span class="cov8" title="1">{
        if c.privateKeyPath != "" </span><span class="cov8" title="1">{
                return true
        }</span> else<span class="cov8" title="1"> {
                return false
        }</span>
}

// GenerateKeys генерирует и сохраняет пару RSA-ключей
// private_key.pem - приватный ключ, public_key.pem - публичный ключ.
func GenerateKeys(savePath string) error <span class="cov8" title="1">{
        // Генерация приватного ключа RSA длиной 4096 бит
        privateKey, err := rsa.GenerateKey(rand.Reader, 4096)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generate key error: %w", err)
        }</span>

        // Сохранение приватного ключа в файл
        <span class="cov8" title="1">privFile, err := os.Create(savePath + "/" + "private_key.pem")
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("create file to save private key error: %w", err)
        }</span>
        <span class="cov8" title="1">defer privFile.Close()

        err = pem.Encode(privFile, &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("encode value and type of key in file error: %w", err)
        }</span>

        // Экспорт публичного ключа из приватного ключа
        <span class="cov8" title="1">publicKey := privateKey.PublicKey

        // Сохранение публичного ключа в файл
        pubFile, err := os.Create(savePath + "/" + "public_key.pem")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create file to save pablic key error: %w", err)
        }</span>
        <span class="cov8" title="1">defer pubFile.Close()

        pubASN1, err := x509.MarshalPKIXPublicKey(&amp;publicKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = pem.Encode(pubFile, &amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: pubASN1,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("encode value and type of key in file error: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ParsePublicKey парсит публичный ключ из файла.
func ParsePublicKey(publicKeyFile string) (*rsa.PublicKey, error) <span class="cov8" title="1">{
        // Чтение публичного ключа из файла
        pubKeyData, err := os.ReadFile(publicKeyFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Декодирование PEM-блока
        <span class="cov8" title="1">block, _ := pem.Decode(pubKeyData)
        if block == nil || block.Type != "PUBLIC KEY" </span><span class="cov8" title="1">{
                return nil, errors.New("error of encoding public key")
        }</span>

        // Парсинг публичного ключа
        <span class="cov8" title="1">pubKey, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rsaPubKey, ok := pubKey.(*rsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("wrong type of public key")
        }</span>
        <span class="cov8" title="1">return rsaPubKey, nil</span>
}

// ParsePrivateKey парсит приватный ключ из файла.
func ParsePrivateKey(privateKeyFile string) (*rsa.PrivateKey, error) <span class="cov8" title="1">{
        // Чтение приватного ключа из файла
        privKeyData, err := os.ReadFile(privateKeyFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Декодирование PEM-блока
        <span class="cov8" title="1">block, _ := pem.Decode(privKeyData)
        if block == nil || block.Type != "RSA PRIVATE KEY" </span><span class="cov8" title="1">{
                return nil, errors.New("error of encoding private key")
        }</span>

        // Парсинг приватного ключа
        <span class="cov8" title="1">privKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return privKey, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package info

import (
        "fmt"
        "io"
)

// Build - функция для печати информации о сборке.
func Build(output io.Writer, buildVersion, buildDate, buildCommit string) <span class="cov8" title="1">{
        fmt.Fprint(output, "Build version: ")
        if buildVersion == "" </span><span class="cov8" title="1">{
                fmt.Fprint(output, "N/A")
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprintf(output, "%s", buildVersion)
        }</span>
        <span class="cov8" title="1">fmt.Fprint(output, "\n")

        fmt.Fprint(output, "Build date: ")
        if buildDate == "" </span><span class="cov8" title="1">{
                fmt.Fprint(output, "N/A")
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprintf(output, "%s", buildDate)
        }</span>
        <span class="cov8" title="1">fmt.Fprint(output, "\n")

        fmt.Fprint(output, "Build commit: ")
        if buildCommit == "" </span><span class="cov8" title="1">{
                fmt.Fprint(output, "N/A")
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprintf(output, "%s", buildCommit)
        }</span>
        <span class="cov8" title="1">fmt.Fprint(output, "\n")</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package ipchecker

import (
        "fmt"
        "net"
        "strings"
)

// InTrustedSubNet - функия проверяет, находится ли переданный Ip в доверенной подсети используя строковое представление CIDR.
func InTrustedSubNet(trustedSubnet, realIP string) (bool, error) <span class="cov8" title="1">{
        _, ipNet, err := net.ParseCIDR(trustedSubnet)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("parse CIDR error: %v", err)
        }</span>

        <span class="cov8" title="1">realIPWithoutPort, err := getClientIP(realIP)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("parse real client ip error %v", err)
        }</span>

        <span class="cov8" title="1">ip := net.ParseIP(realIPWithoutPort)
        if ip == nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("parse real client ip error %v", err)
        }</span>
        <span class="cov8" title="1">return ipNet.Contains(ip), nil</span>
}

// getClientIP - Функция для извлечения IP без порта.
func getClientIP(address string) (string, error) <span class="cov8" title="1">{
        // пытаюсь разделить адрес на хост и порт
        host, _, err := net.SplitHostPort(address)
        if err != nil </span><span class="cov8" title="1">{
                // Если адрес без порта, возвращаем его как есть
                if strings.Contains(err.Error(), "missing port") </span><span class="cov8" title="1">{
                        return address, nil
                }</span>
                <span class="cov8" title="1">return "", fmt.Errorf("failed to parse client address: %w", err)</span>
        }

        // возвращаю только хост (IP-адрес без порта)
        <span class="cov8" title="1">return host, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package ipgetter

import (
        "fmt"
        "net"

        "go.uber.org/zap"

        "github.com/AntonBezemskiy/go-musthave-metrics/internal/server/logger"
)

// Get - функция, которая находит первый попавшийся Ipv4 адрес и возвращает его строковое представление.
func Get() (string, error) <span class="cov8" title="1">{
        // Получаею список всех сетевых интерфейсов
        interfaces, err := net.Interfaces()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("interfaces getting error: %w", err)
        }</span>

        <span class="cov8" title="1">for _, iface := range interfaces </span><span class="cov8" title="1">{
                // Получаю адрес каждого интерфейса
                addrs, err := iface.Addrs()
                if err != nil </span><span class="cov0" title="0">{
                        logger.ServerLog.Error("getting address error", zap.String("error", error.Error(err)))
                        continue</span>
                }
                // Перебираю адреса и вывожу их
                <span class="cov8" title="1">for _, addr := range addrs </span><span class="cov8" title="1">{
                        // проверяю, является ли это IP-адресом IPv4
                        if ipnet, ok := addr.(*net.IPNet); ok &amp;&amp; ipnet.IP.To4() != nil </span><span class="cov8" title="1">{
                                return ipnet.IP.String(), nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("ip address of host is empty")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
